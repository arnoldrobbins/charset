\input texinfo   @c -*-texinfo-*-
@c vim: filetype=texinfo tabstop=4 shiftwidth=4
@c %**start of header (This is for running Texinfo on a region.)
@setfilename charset.info
@settitle Efficient Searching of Large Character Sets --- Take Two
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH January, 2025
@set EDITION 0.4

@set TITLE Efficient Searching of Large Character Sets --- Take Two And A Half
@set SHORTTITLE Searching Character Sets

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@copying
@docbook
<literallayout class="normal">Copyright &copy; 2023, 2024, 2025
Arnold David Robbins
Published under the terms of the 2-Clause BSD license.
See <ulink url="https://opensource.org/license/bsd-2-clause">https://opensource.org/license/bsd-2-clause</ulink>.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} 2023, 2024, 2025 Arnold David Robbins.
Published under the terms of the 2-Clause BSD license.
See @uref{https://opensource.org/license/bsd-2-clause}.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author Arnold David Robbins

@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Arnold David Robbins @*
P.O. Box 354 @*
Nof Ayalon 9978500 @*
ISRAEL @*
Email: @EMAIL{arnold@@skeeve.com,arnold AT skeeve.com} @*
URL: @url{https://www.skeeve.com/} @*

@insertcopying
@end ifnotdocbook
@end titlepage

@set DRAFT

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @code{charset}, a set of functions that accept
a wide character value and search a defined set of characters to
see if the value is in the set.  It is intended for use within
a regular expression matching library.

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@c @summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@node Preface
@unnumbered Preface

This @value{DOCUMENT} documents @code{charset}, a set of functions that accept
a wide character value and search a defined set of characters to
see if the value is in the set.  It is intended for use within
a regular expression matching library.

@menu
* Audience::                    Who should read this @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu

@node Audience
@unnumberedsec Intended Audience

If you're interested in one way to search bracket expressions for
a matching character value when using very large character sets
(such as Unicode), you should read this @value{DOCUMENT}.

@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{https://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@unnumberedsec Acknowledgements

Thanks to Mike Haertel for his feedback, and for giving me the
opportunity to write this bit of code.

@node Introduction
@chapter Introduction

In the fall of 2023, Mike Haertel started writing a new regular expression library,
@uref{https://github.com/mikehaertel/minrx, MinRX},
with the aim of eventually replacing the matchers in use by GNU Awk
(@command{gawk}).  The initial version is in C++; it will eventually be translated
to C for portability. As of August 2024, it's working fully.

As part of the discussion between Mike and myself, I offered a rough draft of a
data structure to use for quickly seeing if a character matches a @dfn{bracket expression},
which is a construct used within regular expressions to represent sets of different
kinds of characters to be matched.
The ideas for this data structure and how to use it had been bouncing around in
my head for some time.

I initially wrote a library---setsearch---that parsed bracket expressions,
built the data structure, and then used it. It's still available at
@uref{https://github.com/arnoldrobbins/setsearch}.  However, further discussion
with Mike revealed that what he really needed was just a data structure for
storing sets of characters and testing an input character against the set;
he preferred to do his own parsing of the bracket expression, and add characters
to the set as needed.

As a result, I designed a new API that still uses the same underlying
data structures. Thus, this @value{DOCUMENT} presents the design and
implementation of a sublibrary (so to speak) for dealing with character
sets.
Almost all of the original setsearch code and literate
documentation are reused here, but in a different way.
In particular, the code for parsing a bracket expression will
come in handy for the test program.

Late in 2024, Mike made some changes in his library that require
changes in @code{charset}. In particular, the way character
classes, such as @code{[:lower:]}, are handled needs to be
done by including the specific ranges of characters that match
the class, instead of using @code{wctype()} and the related
types and functions.  This document and its code are updated
to meet the new requirements. The previous version is available
in the GitHub repository with the tag @samp{before-firstcset-revamp}.

The machine-readable files are available from GitHub. The steps
necessary to get them are:

@example
git clone https://github.com/arnoldrobbins/charset
cd charset
vim jrweave jrtangle    # or emacs :-). Set the path to gawk
make
@end example

@noindent
In order to format the document,
you will need to have @TeX{} and Texinfo installed,
including @command{texi2pdf}.  Or you can ask me for
a PDF, if necessary.

@node Problem Statement
@chapter Problem Statement

Let's first define the problem.  We want a way to represent a defined set of
characters, and then test if any given character is in the set or not.

In the Good Old Days@registeredsymbol{}, with 7-bit ASCII, you could do this
using a bitmap of 128 bits, which would take up only four 32-bit words.
Even for eight bit character sets, you'd only need eight 32-bit words.

In Unicode, which has over a million characters, a bit map would be very big.
In particular, it's likely that it would be mostly empty; such sets of characters
may have a few dozen or so characters in them, but not thousands or hundreds of thousands.

Therefore, we need a data structure that is efficient in two dimensions:
time for searching, and space that it occupies. I think the data structure
presented here meets both criteria.

@node The Data Structure
@chapter The Underlying Data Structure

We'll start with the underlying data structure.

A single item in the set is represented by
a set item:

@<data structures@>=
typedef struct set_item {
		int32_t start, end;
} set_item;
@

A @code{set_item} holds
a range, such as @code{[a-z]}.
Single characters that
aren't contiguous with others are placed in a range where
@code{start} and @code{end} are set to the same value.

The full @code{charset_t} holds a dynamically allocated
array of @code{set_item}s, items needed for building
the set, and what's needed for managing
the memory:

@<data structures@>=
struct _charset {
	bool     no_newlines;       // If \n can't be in the set
	bool     finalized;         // No more changes possible
	bool	 is_utf8;			// True if using a UTF-8 character set
	int		 mb_cur_max;		// Value of MB_CUR_MAX when the charset was created
	size_t   nchars_inuse;      // Number of characters used
	size_t   nchars_allocated;  // Number of characters allocated
	int32_t  *chars;            // Characters added to the set
	size_t   nelems;            // Number of elements (items) in use
	size_t   allocated;         // Number allocated
	set_item *items;            // Array of items
};
@

We will see how it's built up and used as we go along.

@node API Functions
@chapter API Functions

Here are the functions for the API.

@node Error Codes
@section Error Codes

Almost all of the functions return a success or error value via a
pointer to a plain integer. Here are the error codes:

@<error codes@>=
// error code values:
enum {
	CSET_SUCCESS = 0,	// No problems
	CSET_EBADPTR,		// NULL pointer received
	CSET_EFROZEN,		// Cannot add more characters to the set
	CSET_ECOLLATE,		// Corresponds to REG_ECOLLATE
	CSET_ECTYPE,		// Corresponds to REG_ECTYPE
	CSET_ESPACE,		// Corresponds to REG_ESPACE
	CSET_ERANGE,		// Corresponds to REG_ERANGE
};
@

@<API declarations@>=
@<error codes@>
@

@node Creating The Charset
@section Creating The Charset

Creating the character set simply
allocates the memory and forces it to zero.

@<API functions@>=
/* charset_create --- make a new charset_t and initialize it */

charset_t *
charset_create(int *errcode, int mb_cur_max, bool is_utf8)
{
	if (errcode == NULL)
		return NULL;

	charset_t *set = (charset_t *) malloc(sizeof(charset_t));
	if (set == NULL) {
		*errcode = CSET_ESPACE;
		return NULL;
	}

	memset(set, 0, sizeof(charset_t));
	set->mb_cur_max = mb_cur_max;
	set->is_utf8 = is_utf8;

	*errcode = CSET_SUCCESS;
	return set;
}
@

@<API declarations@>=
charset_t *charset_create(int *errcode, int mb_cur_max, bool is_utf8);
@

@node Adding A Character
@section Adding A Character

The @code{charset_t} is intended for matching bracket expressions,
which can have multiple single characters, ranges, and other objects.
The most fundamental object is a single character, for example,
@code{[aeiouy]}.  As the regex engine parses the bracket expression,
it adds characters to the @code{charset_t} one at a time.

Note that nothing prevents a user from writing a bracket expression
like this: @code{[aeiouyAEIOUYaeiouy]}, where letters are repeated.
We handle this later on, when building the final data structure.
Initially, we simply add each character into @code{set->chars}.

The API functions return an error code; @code{CSET_SUCCESS} is for
when everything is good.

@<API functions@>=
/* charset_add_char --- add a single wide character to the set */

int
charset_add_char(charset_t *set, int32_t wc)
{
	@<check for NULL pointer@>
	@<check if finalized@>

	if (wc < 0)
		return CSET_ERANGE;

	@<create or grow the array of wide characters@>

	set->chars[set->nchars_inuse++] = wc;
	set->chars[set->nchars_inuse] = L'\0';	// make it into a string

	return CSET_SUCCESS;
}
@

We check for a @code{NULL} pointer in every function:

@<check for NULL pointer@>=
if (set == NULL)
	return CSET_EBADPTR;
@

We use the term @dfn{finalized} to mean that we have
already built the final data structures. This occurs
(as we'll see later) the first time the set is tested
for membership of a character, and in a few other instances.
The set may also be finalized by the user.   Until it's finalized, characters,
ranges, and other things may be added willy-nilly to
the @code{charset_t}; finalizing cleans it all up.
However, once finalized, nothing more may be added;
we check that in almost every API function.

@<check if finalized@>=
if (set->finalized)
	return CSET_EFROZEN;
@

The array of wide characters must be held in the @code{charset_t},
since items are added incrementally, and not all at once as
in the previous incarnation (setsearch). The code to create
or grow the array follows a standard pattern.

@<create or grow the array of wide characters@>=
if (set->chars == NULL) {
	set->chars = (int32_t *) malloc(sizeof(int32_t) * INITIAL_ALLOCATION);
	if (set->chars == NULL)
		return CSET_ESPACE;

	set->nchars_allocated = INITIAL_ALLOCATION;
	set->nchars_inuse = 0;
} else if (set->nchars_inuse + 1 >= set->nchars_allocated) {
	int new_amount = set->nchars_allocated * 2;
	int32_t *new_data = (int32_t *) realloc(set->chars, new_amount * sizeof(int32_t));

	if (new_data == NULL)
		return CSET_ESPACE;

	memset(new_data + set->nchars_allocated, 0, set->nchars_allocated * sizeof(int32_t));
	set->nchars_allocated = new_amount;
	set->chars = new_data;
}
@

@<macros@>=
#define INITIAL_ALLOCATION 10
@

@<API declarations@>=
int charset_add_char(charset_t *set, int32_t wc);
@

@node Adding Ranges
@section Adding Ranges

As mentioned, a range looks like @code{[a-z]}.  Ranges are held
in @code{set_item}s.
The left hand value must be less than or equal
to the right hand value.

Here too, a user can write something (silly) like @code{[a-eqra-ezhb-d]}
This will initially create three @code{RANGE_ITEM}s, @code{a-e}, @code{a-e} (a
second time) and @code{b-d}.  The final range is subsumed within the
first one.  Finalizing the data structure cleans all this up so that in
the end there is only one @code{set_item}, for @code{a-e}.

@<API functions@>=
/* charset_add_range --- add a range item */

int
charset_add_range(charset_t *set, int32_t first, int32_t last)
{
	@<check for NULL pointer@>
	@<check if finalized@>

	if (first < 0 || last < 0 || first > last)
		return CSET_ERANGE;

	@<create or grow the set of items if necessary@>

	set_item new_item;
	new_item.start = first;
	new_item.end = last;
	set->items[set->nelems++] = new_item;

	return CSET_SUCCESS;
}
@

This code follows the same pattern as for dealing with the array of characters.

@<create or grow the set of items if necessary@>=
if (set->items == NULL) {
	set->items = (set_item *) malloc(sizeof(set_item) * INITIAL_ALLOCATION);
	if (set->items == NULL)
		return CSET_ESPACE;

	set->allocated = INITIAL_ALLOCATION;
	set->nelems = 0;
} else if (set->nelems + 1 >= set->allocated) {
	int new_amount = set->allocated * 2;
	set_item *new_data = (set_item *) realloc(set->items, new_amount * sizeof(set_item));

	if (new_data == NULL)
		return CSET_ESPACE;

	memset(new_data + set->allocated, 0, set->allocated * sizeof(set_item));
	set->allocated = new_amount;
	set->items = new_data;
}
@


@<API declarations@>=
int charset_add_range(charset_t *set, int32_t first, int32_t last);
@

@node Inverting
@section Inverting The Charset

A bracket expression may @dfn{complemented}, meaning that it should match
any character @emph{not} in the set. For example, @code{[^aeiouyAEIOUY]}
matches any non-vowel character (for English). In previous versions, we
simply marked the @code{charset_t} as being complemented. To support
the new requirements, instead we must invert the set of ranges.
This is done by returning a brand new structure containing the
inverted ranges.

@<API functions@>=
/* charset_invert --- invert the ranges in set and return a new set */

charset_t *
charset_invert(charset_t *set, int *errcode)
{
	if (errcode == NULL)
		return NULL;

	@<check for NULL pointer@>
	if (! set->finalized) {
		int ret = charset_finalize(set);

		if (! set->finalized) {
			*errcode = ret;
			return NULL;
		}
	}

	charset_t *newset = charset_create(errcode, set->mb_cur_max, set->is_utf8);
	if (newset == NULL)
		return NULL;

	newset->no_newlines = set->no_newlines;

	if (set->nelems == 0) {	// was empty
		int ret = charset_add_range(newset, 0, MAX_CODE_POINT);
		if (ret != CSET_SUCCESS)
			goto fail;
	}

	int low = 0;
	int ret;

	for (int i = 0; i < set->nelems; i++) {
		if (low < set->items[i].start) {
			if ((ret = charset_add_range(newset, low, set->items[i].start - 1)) != CSET_SUCCESS)
				goto fail;
		}
		low = set->items[i].end + 1;
	}
	if (low <= MAX_CODE_POINT) {
			if ((ret = charset_add_range(newset, low, MAX_CODE_POINT)) != CSET_SUCCESS)
				goto fail;
		}
	}

	*errcode = CSET_SUCCESS;
	return newset;
fail:
	*errcode = ret;
	charset_free(newset);
	return NULL;
}
@

@<API declarations@>=
charset_t *charset_invert(charset_t *set, int *errcode);
@

@<macros@>=
#define MAX_CODE_POINT 0x10ffff	// max Unicode code point
@

@node No newlines
@section Setting The ``no newlines'' Flag

There are two cases where we may want a newline to not be allowed to match.
The first is in an inverted character set.
The second is if we choose to not let dot match newline.
The first case is handled when we check a character for membership
in the set. The second is handled by explicitly setting the @code{no_newlines}
flag.

@<API functions@>=
/* charset_set_no_newline --- set the value of the "no newlines" flag */

int charset_set_no_newlines(charset_t *set, bool no_newlines)
{
	@<check for NULL pointer@>
	@<check if finalized@>

	set->no_newlines = no_newlines;
	return CSET_SUCCESS;
}
@

@<API declarations@>=
int charset_set_no_newlines(charset_t *set, bool no_newlines);
@

@node Some Of The Funky Stuff
@section Equivalence Classes, and Collating Sequences

Besides characters and ranges, POSIX specifies three additional kinds of
items that can occur inside a bracket expression, and which we have to
be able to handle: character classes, equivalence classes, and collating
sequences.

We will deal with character classes separately, as they're complicated.

@node Equivalence Classes
@subsection Equivalence Classes

An equivalence class describes a set of equivalent characters.
For example, in a French locale, @code{[[=e=]]} might match @code{e}, 
@code{@^e}, @code{@`e}, and @code{@'e}.

Here is Mike's portable but ``sleazy'' (sic) way to add all
the equivalent characters:

@<API functions@>=
/* charset_add_equiv --- add an equivalence class */

int
charset_add_equiv(charset_t *set, int32_t equiv)
{
	@<check for NULL pointer@>
	@<check if finalized@>

	if (equiv < 0)
		return CSET_ERANGE;

	wchar_t wcs_in[2];
	wchar_t wcs[2];
	wchar_t abuf[100], wbuf[100];
	int result;

	wcs_in[0] = equiv;
	wcs_in[1] = 0;
	wcsxfrm(abuf, wcs_in, 99);
	wcs[1] = 0;
	for (wchar_t u = 1; u <= MAX_CODE_POINT; ++u) {
		wcs[0] = u;
		wcsxfrm(wbuf, wcs, 99);
		if (abuf[0] == wbuf[0])
			if ((result = charset_add_char(set, u)) != CSET_SUCCESS)
				return result;
	}

	return CSET_SUCCESS;
}
@

@<API declarations@>=
int charset_add_equiv(charset_t *set, int32_t equiv);
@

@node Collating Sequences
@subsection  Collating Sequences

A collating sequence is a group of characters that should be
treated as if it were a single character. It might be written
like @code{[[.oa.]]}.  We support collating sequences of length one.

@<API functions@>=
/* charset_add_collate --- add a collating sequence */

int
charset_add_collate(charset_t *set, const int32_t *collate)
{
	@<check for NULL pointer@>
	@<check if finalized@>

	// only single character collating sequences allowed,
	// at least right now
	if (collate[1] != L'\0')
		return CSET_ECOLLATE;

	return charset_add_char(set, collate[0]);
}
@

@<API declarations@>=
int charset_add_collate(charset_t *set, const int32_t *collate);
@

@node Character Classes
@section  Character Classes

Character classes provide a locale-independent way of matching
groups of characters, such as ``alphabetic'' or ``punctuation.''
You write them like so: @code{[[:alpha:]]}. In other words,
delimited by @code{[:} and @code{:]} inside the outer brackets
of the bracket expression.

Character class handling is complicated.  In the previous incarnation
of this code, we used the @code{wctype()} suite of functions, which pushes
the work off onto the C library.  In this version, we have to add
the correct set of characters as ranges to the charset.

For Unicode, this is easy, we can use predefined sets of ranges for
the standard sets. For eight-bit character sets, we can manually
test all 256 values from zero to 255. For other cases, we have to
manually loop over all possible characters. We make an attempt
to avoid doing this more than once for any combination of locale and
character class.  Let's get started.

@node Predefined Ranges
@subsection Predefined Sets of Ranges For Unicode

We'll start with the predefined sets of ranges.
These were produced using the code in @ref{Generating Ranges}.

We rely on the fact that @samp{alnum} can be composed from
@samp{alpha} and @samp{digit}. Similarly, @samp{print} and
@samp{graph} share most of the same ranges, so we have a set
of what's common for both, and then what's additional for
each. We'll see how they can be combined in a bit.
The final entry in each range is @samp{-1, -1}, to serve
as end markers when looping through the data.

Here are the ranges. For presentation in the document, we've
omitted many hundreds of lines of ranges; they are included
in the generated code.

@<static data@>=
static set_item digit[] = {
	{ 48, 57 },
	{ -1, -1 },	// end markers
};
static set_item cntrl[] = {
	{ 0, 31 },
	{ 127, 159 },
	{ 8232, 8233 },
	{ -1, -1 },	// end markers
};
static set_item xdigit[] = {
	{ 48, 57 },
	{ 65, 70 },
	{ 97, 102 },
	{ -1, -1 },	// end markers
};
static set_item print_additional[] = {
	{ 32, 126 },
	{ 5120, 5788 },
	{ 8192, 8231 },
	{ 8234, 8292 },
	{ 12288, 12351 },
	{ -1, -1 },	// end markers
};
static set_item blank[] = {
	{ 9, 9 },
	{ 32, 32 },
	{ 5760, 5760 },
	{ 8192, 8198 },
	{ 8200, 8202 },
	{ 8287, 8287 },
	{ 12288, 12288 },
	{ -1, -1 },	// end markers
};
static set_item graph_additional[] = {
	{ 33, 126 },
	{ 5120, 5759 },
	{ 5761, 5788 },
	{ 8199, 8199 },
	{ 8203, 8231 },
	{ 8234, 8286 },
	{ 8288, 8292 },
	{ 12289, 12351 },
	{ -1, -1 },	// end markers
};
static set_item space[] = {
	{ 9, 13 },
	{ 32, 32 },
	{ 5760, 5760 },
	{ 8192, 8198 },
	{ 8200, 8202 },
	{ 8232, 8233 },
	{ 8287, 8287 },
	{ 12288, 12288 },
	{ -1, -1 },	// end markers
};
static set_item punct[] = {
	{ 33, 47 },
@ifweave
	...
@end ifweave
@iftangle
	{ 58, 64 },
	{ 91, 96 },
	{ 123, 126 },
	{ 160, 169 },
	{ 171, 180 },
	{ 182, 185 },
	{ 187, 191 },
	{ 215, 215 },
	{ 247, 247 },
	{ 706, 709 },
	{ 722, 735 },
	{ 741, 747 },
	{ 749, 749 },
	{ 751, 836 },
	{ 838, 879 },
	{ 885, 885 },
	{ 894, 894 },
	{ 900, 901 },
	{ 903, 903 },
	{ 1014, 1014 },
	{ 1154, 1161 },
	{ 1370, 1375 },
	{ 1417, 1418 },
	{ 1421, 1423 },
	{ 1425, 1455 },
	{ 1470, 1470 },
	{ 1472, 1472 },
	{ 1475, 1475 },
	{ 1478, 1478 },
	{ 1523, 1524 },
	{ 1536, 1551 },
	{ 1563, 1567 },
	{ 1624, 1624 },
	{ 1642, 1645 },
	{ 1748, 1748 },
	{ 1757, 1760 },
	{ 1769, 1772 },
	{ 1789, 1790 },
	{ 1792, 1805 },
	{ 1807, 1807 },
	{ 1856, 1866 },
	{ 2027, 2035 },
	{ 2038, 2041 },
	{ 2045, 2047 },
	{ 2072, 2073 },
	{ 2093, 2093 },
	{ 2096, 2110 },
	{ 2137, 2139 },
	{ 2142, 2142 },
	{ 2184, 2184 },
	{ 2192, 2193 },
	{ 2200, 2207 },
	{ 2250, 2259 },
	{ 2272, 2274 },
	{ 2282, 2287 },
	{ 2364, 2364 },
	{ 2381, 2381 },
	{ 2385, 2388 },
	{ 2404, 2405 },
	{ 2416, 2416 },
	{ 2492, 2492 },
	{ 2509, 2509 },
	{ 2546, 2555 },
	{ 2557, 2558 },
	{ 2620, 2620 },
	{ 2637, 2637 },
	{ 2678, 2678 },
	{ 2748, 2748 },
	{ 2765, 2765 },
	{ 2800, 2801 },
	{ 2813, 2815 },
	{ 2876, 2876 },
	{ 2893, 2893 },
	{ 2901, 2901 },
	{ 2928, 2928 },
	{ 2930, 2935 },
	{ 3021, 3021 },
	{ 3056, 3066 },
	{ 3076, 3076 },
	{ 3132, 3132 },
	{ 3149, 3149 },
	{ 3191, 3199 },
	{ 3204, 3204 },
	{ 3260, 3260 },
	{ 3277, 3277 },
	{ 3387, 3388 },
	{ 3405, 3405 },
	{ 3407, 3407 },
	{ 3416, 3422 },
	{ 3440, 3449 },
	{ 3530, 3530 },
	{ 3572, 3572 },
	{ 3647, 3647 },
	{ 3655, 3660 },
	{ 3662, 3663 },
	{ 3674, 3675 },
	{ 3770, 3770 },
	{ 3784, 3788 },
	{ 3841, 3871 },
	{ 3882, 3903 },
	{ 3970, 3975 },
	{ 4030, 4044 },
	{ 4046, 4058 },
	{ 4151, 4151 },
	{ 4153, 4154 },
	{ 4170, 4175 },
	{ 4254, 4255 },
	{ 4347, 4347 },
	{ 4957, 4988 },
	{ 5008, 5017 },
	{ 5120, 5120 },
	{ 5741, 5742 },
	{ 5787, 5788 },
	{ 5867, 5869 },
	{ 5908, 5909 },
	{ 5940, 5942 },
	{ 6068, 6069 },
	{ 6089, 6102 },
	{ 6104, 6107 },
	{ 6109, 6109 },
	{ 6128, 6137 },
	{ 6144, 6159 },
	{ 6457, 6459 },
	{ 6464, 6464 },
	{ 6468, 6469 },
	{ 6618, 6618 },
	{ 6622, 6655 },
	{ 6686, 6687 },
	{ 6752, 6752 },
	{ 6773, 6780 },
	{ 6783, 6783 },
	{ 6816, 6822 },
	{ 6824, 6829 },
	{ 6832, 6846 },
	{ 6849, 6859 },
	{ 6964, 6964 },
	{ 6980, 6980 },
	{ 7002, 7038 },
	{ 7082, 7083 },
	{ 7142, 7142 },
	{ 7154, 7155 },
	{ 7164, 7167 },
	{ 7223, 7223 },
	{ 7227, 7231 },
	{ 7294, 7295 },
	{ 7360, 7367 },
	{ 7376, 7400 },
	{ 7405, 7405 },
	{ 7412, 7412 },
	{ 7415, 7417 },
	{ 7616, 7654 },
	{ 7669, 7679 },
	{ 8125, 8125 },
	{ 8127, 8129 },
	{ 8141, 8143 },
	{ 8157, 8159 },
	{ 8173, 8175 },
	{ 8189, 8190 },
	{ 8199, 8199 },
	{ 8203, 8231 },
	{ 8234, 8286 },
	{ 8288, 8292 },
	{ 8294, 8304 },
	{ 8308, 8318 },
	{ 8320, 8334 },
	{ 8352, 8384 },
	{ 8400, 8432 },
	{ 8448, 8449 },
	{ 8451, 8454 },
	{ 8456, 8457 },
	{ 8468, 8468 },
	{ 8470, 8472 },
	{ 8478, 8483 },
	{ 8485, 8485 },
	{ 8487, 8487 },
	{ 8489, 8489 },
	{ 8494, 8494 },
	{ 8506, 8507 },
	{ 8512, 8516 },
	{ 8522, 8525 },
	{ 8527, 8543 },
	{ 8585, 8587 },
	{ 8592, 9254 },
	{ 9280, 9290 },
	{ 9312, 9397 },
	{ 9450, 11123 },
	{ 11126, 11157 },
	{ 11159, 11263 },
	{ 11493, 11498 },
	{ 11503, 11505 },
	{ 11513, 11519 },
	{ 11632, 11632 },
	{ 11647, 11647 },
	{ 11776, 11822 },
	{ 11824, 11869 },
	{ 11904, 11929 },
	{ 11931, 12019 },
	{ 12032, 12245 },
	{ 12272, 12283 },
	{ 12289, 12292 },
	{ 12296, 12320 },
	{ 12330, 12336 },
	{ 12342, 12343 },
	{ 12349, 12351 },
	{ 12441, 12444 },
	{ 12448, 12448 },
	{ 12539, 12539 },
	{ 12688, 12703 },
	{ 12736, 12771 },
	{ 12800, 12830 },
	{ 12832, 13311 },
	{ 19904, 19967 },
	{ 42128, 42182 },
	{ 42238, 42239 },
	{ 42509, 42511 },
	{ 42607, 42611 },
	{ 42620, 42622 },
	{ 42736, 42743 },
	{ 42752, 42774 },
	{ 42784, 42785 },
	{ 42889, 42890 },
	{ 43014, 43014 },
	{ 43048, 43052 },
	{ 43056, 43065 },
	{ 43124, 43127 },
	{ 43204, 43204 },
	{ 43214, 43215 },
	{ 43232, 43249 },
	{ 43256, 43258 },
	{ 43260, 43260 },
	{ 43307, 43311 },
	{ 43347, 43347 },
	{ 43359, 43359 },
	{ 43443, 43443 },
	{ 43456, 43469 },
	{ 43486, 43487 },
	{ 43612, 43615 },
	{ 43639, 43641 },
	{ 43711, 43711 },
	{ 43713, 43713 },
	{ 43742, 43743 },
	{ 43760, 43761 },
	{ 43766, 43766 },
	{ 43867, 43867 },
	{ 43882, 43883 },
	{ 44011, 44013 },
	{ 57344, 63743 },
	{ 64297, 64297 },
	{ 64434, 64450 },
	{ 64830, 64847 },
	{ 64975, 64975 },
	{ 65020, 65049 },
	{ 65056, 65106 },
	{ 65108, 65126 },
	{ 65128, 65131 },
	{ 65279, 65279 },
	{ 65281, 65295 },
	{ 65306, 65312 },
	{ 65339, 65344 },
	{ 65371, 65381 },
	{ 65504, 65510 },
	{ 65512, 65518 },
	{ 65529, 65533 },
	{ 65792, 65794 },
	{ 65799, 65843 },
	{ 65847, 65855 },
	{ 65909, 65934 },
	{ 65936, 65948 },
	{ 65952, 65952 },
	{ 66000, 66045 },
	{ 66272, 66299 },
	{ 66336, 66339 },
	{ 66463, 66463 },
	{ 66512, 66512 },
	{ 66927, 66927 },
	{ 67671, 67679 },
	{ 67703, 67711 },
	{ 67751, 67759 },
	{ 67835, 67839 },
	{ 67862, 67867 },
	{ 67871, 67871 },
	{ 67903, 67903 },
	{ 68028, 68029 },
	{ 68032, 68047 },
	{ 68050, 68095 },
	{ 68152, 68154 },
	{ 68159, 68168 },
	{ 68176, 68184 },
	{ 68221, 68223 },
	{ 68253, 68255 },
	{ 68296, 68296 },
	{ 68325, 68326 },
	{ 68331, 68342 },
	{ 68409, 68415 },
	{ 68440, 68447 },
	{ 68472, 68479 },
	{ 68505, 68508 },
	{ 68521, 68527 },
	{ 68858, 68863 },
	{ 69216, 69246 },
	{ 69293, 69293 },
	{ 69405, 69414 },
	{ 69446, 69465 },
	{ 69506, 69513 },
	{ 69573, 69579 },
	{ 69702, 69709 },
	{ 69714, 69733 },
	{ 69744, 69744 },
	{ 69759, 69761 },
	{ 69817, 69825 },
	{ 69837, 69837 },
	{ 69939, 69940 },
	{ 69952, 69955 },
	{ 70003, 70005 },
	{ 70080, 70080 },
	{ 70085, 70093 },
	{ 70107, 70107 },
	{ 70109, 70111 },
	{ 70113, 70132 },
	{ 70197, 70198 },
	{ 70200, 70205 },
	{ 70313, 70313 },
	{ 70377, 70378 },
	{ 70459, 70460 },
	{ 70477, 70477 },
	{ 70502, 70508 },
	{ 70512, 70516 },
	{ 70722, 70722 },
	{ 70726, 70726 },
	{ 70731, 70735 },
	{ 70746, 70747 },
	{ 70749, 70750 },
	{ 70850, 70851 },
	{ 70854, 70854 },
	{ 71103, 71127 },
	{ 71231, 71231 },
	{ 71233, 71235 },
	{ 71264, 71276 },
	{ 71350, 71351 },
	{ 71353, 71353 },
	{ 71467, 71467 },
	{ 71482, 71487 },
	{ 71737, 71739 },
	{ 71914, 71922 },
	{ 71997, 71998 },
	{ 72003, 72006 },
	{ 72160, 72160 },
	{ 72162, 72162 },
	{ 72243, 72244 },
	{ 72255, 72263 },
	{ 72344, 72348 },
	{ 72350, 72354 },
	{ 72767, 72767 },
	{ 72769, 72773 },
	{ 72794, 72812 },
	{ 72816, 72817 },
	{ 73026, 73026 },
	{ 73028, 73029 },
	{ 73111, 73111 },
	{ 73463, 73464 },
	{ 73664, 73713 },
	{ 73727, 73727 },
	{ 74864, 74868 },
	{ 77809, 77810 },
	{ 78896, 78904 },
	{ 92782, 92783 },
	{ 92912, 92917 },
	{ 92976, 92991 },
	{ 92996, 92997 },
	{ 93019, 93025 },
	{ 93824, 93850 },
	{ 94178, 94178 },
	{ 94180, 94180 },
	{ 113820, 113821 },
	{ 113823, 113827 },
	{ 118528, 118573 },
	{ 118576, 118598 },
	{ 118608, 118723 },
	{ 118784, 119029 },
	{ 119040, 119078 },
	{ 119081, 119274 },
	{ 119296, 119365 },
	{ 119520, 119539 },
	{ 119552, 119638 },
	{ 119648, 119672 },
	{ 120513, 120513 },
	{ 120539, 120539 },
	{ 120571, 120571 },
	{ 120597, 120597 },
	{ 120629, 120629 },
	{ 120655, 120655 },
	{ 120687, 120687 },
	{ 120713, 120713 },
	{ 120745, 120745 },
	{ 120771, 120771 },
	{ 120832, 121483 },
	{ 121499, 121503 },
	{ 121505, 121519 },
	{ 123184, 123190 },
	{ 123215, 123215 },
	{ 123566, 123566 },
	{ 123628, 123631 },
	{ 123647, 123647 },
	{ 125127, 125142 },
	{ 125252, 125254 },
	{ 125256, 125258 },
	{ 125278, 125279 },
	{ 126065, 126132 },
	{ 126209, 126269 },
	{ 126704, 126705 },
	{ 126976, 127019 },
	{ 127024, 127123 },
	{ 127136, 127150 },
	{ 127153, 127167 },
	{ 127169, 127183 },
	{ 127185, 127221 },
	{ 127232, 127279 },
	{ 127306, 127311 },
	{ 127338, 127343 },
	{ 127370, 127405 },
	{ 127462, 127490 },
	{ 127504, 127547 },
	{ 127552, 127560 },
	{ 127568, 127569 },
	{ 127584, 127589 },
	{ 127744, 128727 },
	{ 128733, 128748 },
	{ 128752, 128764 },
	{ 128768, 128883 },
	{ 128896, 128984 },
	{ 128992, 129003 },
	{ 129008, 129008 },
	{ 129024, 129035 },
	{ 129040, 129095 },
	{ 129104, 129113 },
	{ 129120, 129159 },
	{ 129168, 129197 },
	{ 129200, 129201 },
	{ 129280, 129619 },
	{ 129632, 129645 },
	{ 129648, 129652 },
	{ 129656, 129660 },
	{ 129664, 129670 },
	{ 129680, 129708 },
	{ 129712, 129722 },
	{ 129728, 129733 },
	{ 129744, 129753 },
	{ 129760, 129767 },
	{ 129776, 129782 },
	{ 129792, 129938 },
	{ 129940, 129994 },
	{ 917505, 917505 },
	{ 917536, 917631 },
	{ 917760, 917999 },
	{ 983040, 1048573 },
	{ 1048576, 1114109 },
@end iftangle
	{ -1, -1 },	// end markers
};
static set_item upper[] = {
	{ 65, 90 },
@ifweave
	...
@end ifweave
@iftangle
	{ 192, 214 },
	{ 216, 222 },
	{ 256, 256 },
	{ 258, 258 },
	{ 260, 260 },
	{ 262, 262 },
	{ 264, 264 },
	{ 266, 266 },
	{ 268, 268 },
	{ 270, 270 },
	{ 272, 272 },
	{ 274, 274 },
	{ 276, 276 },
	{ 278, 278 },
	{ 280, 280 },
	{ 282, 282 },
	{ 284, 284 },
	{ 286, 286 },
	{ 288, 288 },
	{ 290, 290 },
	{ 292, 292 },
	{ 294, 294 },
	{ 296, 296 },
	{ 298, 298 },
	{ 300, 300 },
	{ 302, 302 },
	{ 304, 304 },
	{ 306, 306 },
	{ 308, 308 },
	{ 310, 310 },
	{ 313, 313 },
	{ 315, 315 },
	{ 317, 317 },
	{ 319, 319 },
	{ 321, 321 },
	{ 323, 323 },
	{ 325, 325 },
	{ 327, 327 },
	{ 330, 330 },
	{ 332, 332 },
	{ 334, 334 },
	{ 336, 336 },
	{ 338, 338 },
	{ 340, 340 },
	{ 342, 342 },
	{ 344, 344 },
	{ 346, 346 },
	{ 348, 348 },
	{ 350, 350 },
	{ 352, 352 },
	{ 354, 354 },
	{ 356, 356 },
	{ 358, 358 },
	{ 360, 360 },
	{ 362, 362 },
	{ 364, 364 },
	{ 366, 366 },
	{ 368, 368 },
	{ 370, 370 },
	{ 372, 372 },
	{ 374, 374 },
	{ 376, 377 },
	{ 379, 379 },
	{ 381, 381 },
	{ 385, 386 },
	{ 388, 388 },
	{ 390, 391 },
	{ 393, 395 },
	{ 398, 401 },
	{ 403, 404 },
	{ 406, 408 },
	{ 412, 413 },
	{ 415, 416 },
	{ 418, 418 },
	{ 420, 420 },
	{ 422, 423 },
	{ 425, 425 },
	{ 428, 428 },
	{ 430, 431 },
	{ 433, 435 },
	{ 437, 437 },
	{ 439, 440 },
	{ 444, 444 },
	{ 452, 453 },
	{ 455, 456 },
	{ 458, 459 },
	{ 461, 461 },
	{ 463, 463 },
	{ 465, 465 },
	{ 467, 467 },
	{ 469, 469 },
	{ 471, 471 },
	{ 473, 473 },
	{ 475, 475 },
	{ 478, 478 },
	{ 480, 480 },
	{ 482, 482 },
	{ 484, 484 },
	{ 486, 486 },
	{ 488, 488 },
	{ 490, 490 },
	{ 492, 492 },
	{ 494, 494 },
	{ 497, 498 },
	{ 500, 500 },
	{ 502, 504 },
	{ 506, 506 },
	{ 508, 508 },
	{ 510, 510 },
	{ 512, 512 },
	{ 514, 514 },
	{ 516, 516 },
	{ 518, 518 },
	{ 520, 520 },
	{ 522, 522 },
	{ 524, 524 },
	{ 526, 526 },
	{ 528, 528 },
	{ 530, 530 },
	{ 532, 532 },
	{ 534, 534 },
	{ 536, 536 },
	{ 538, 538 },
	{ 540, 540 },
	{ 542, 542 },
	{ 544, 544 },
	{ 546, 546 },
	{ 548, 548 },
	{ 550, 550 },
	{ 552, 552 },
	{ 554, 554 },
	{ 556, 556 },
	{ 558, 558 },
	{ 560, 560 },
	{ 562, 562 },
	{ 570, 571 },
	{ 573, 574 },
	{ 577, 577 },
	{ 579, 582 },
	{ 584, 584 },
	{ 586, 586 },
	{ 588, 588 },
	{ 590, 590 },
	{ 880, 880 },
	{ 882, 882 },
	{ 886, 886 },
	{ 895, 895 },
	{ 902, 902 },
	{ 904, 906 },
	{ 908, 908 },
	{ 910, 911 },
	{ 913, 929 },
	{ 931, 939 },
	{ 975, 975 },
	{ 978, 980 },
	{ 984, 984 },
	{ 986, 986 },
	{ 988, 988 },
	{ 990, 990 },
	{ 992, 992 },
	{ 994, 994 },
	{ 996, 996 },
	{ 998, 998 },
	{ 1000, 1000 },
	{ 1002, 1002 },
	{ 1004, 1004 },
	{ 1006, 1006 },
	{ 1012, 1012 },
	{ 1015, 1015 },
	{ 1017, 1018 },
	{ 1021, 1071 },
	{ 1120, 1120 },
	{ 1122, 1122 },
	{ 1124, 1124 },
	{ 1126, 1126 },
	{ 1128, 1128 },
	{ 1130, 1130 },
	{ 1132, 1132 },
	{ 1134, 1134 },
	{ 1136, 1136 },
	{ 1138, 1138 },
	{ 1140, 1140 },
	{ 1142, 1142 },
	{ 1144, 1144 },
	{ 1146, 1146 },
	{ 1148, 1148 },
	{ 1150, 1150 },
	{ 1152, 1152 },
	{ 1162, 1162 },
	{ 1164, 1164 },
	{ 1166, 1166 },
	{ 1168, 1168 },
	{ 1170, 1170 },
	{ 1172, 1172 },
	{ 1174, 1174 },
	{ 1176, 1176 },
	{ 1178, 1178 },
	{ 1180, 1180 },
	{ 1182, 1182 },
	{ 1184, 1184 },
	{ 1186, 1186 },
	{ 1188, 1188 },
	{ 1190, 1190 },
	{ 1192, 1192 },
	{ 1194, 1194 },
	{ 1196, 1196 },
	{ 1198, 1198 },
	{ 1200, 1200 },
	{ 1202, 1202 },
	{ 1204, 1204 },
	{ 1206, 1206 },
	{ 1208, 1208 },
	{ 1210, 1210 },
	{ 1212, 1212 },
	{ 1214, 1214 },
	{ 1216, 1217 },
	{ 1219, 1219 },
	{ 1221, 1221 },
	{ 1223, 1223 },
	{ 1225, 1225 },
	{ 1227, 1227 },
	{ 1229, 1229 },
	{ 1232, 1232 },
	{ 1234, 1234 },
	{ 1236, 1236 },
	{ 1238, 1238 },
	{ 1240, 1240 },
	{ 1242, 1242 },
	{ 1244, 1244 },
	{ 1246, 1246 },
	{ 1248, 1248 },
	{ 1250, 1250 },
	{ 1252, 1252 },
	{ 1254, 1254 },
	{ 1256, 1256 },
	{ 1258, 1258 },
	{ 1260, 1260 },
	{ 1262, 1262 },
	{ 1264, 1264 },
	{ 1266, 1266 },
	{ 1268, 1268 },
	{ 1270, 1270 },
	{ 1272, 1272 },
	{ 1274, 1274 },
	{ 1276, 1276 },
	{ 1278, 1278 },
	{ 1280, 1280 },
	{ 1282, 1282 },
	{ 1284, 1284 },
	{ 1286, 1286 },
	{ 1288, 1288 },
	{ 1290, 1290 },
	{ 1292, 1292 },
	{ 1294, 1294 },
	{ 1296, 1296 },
	{ 1298, 1298 },
	{ 1300, 1300 },
	{ 1302, 1302 },
	{ 1304, 1304 },
	{ 1306, 1306 },
	{ 1308, 1308 },
	{ 1310, 1310 },
	{ 1312, 1312 },
	{ 1314, 1314 },
	{ 1316, 1316 },
	{ 1318, 1318 },
	{ 1320, 1320 },
	{ 1322, 1322 },
	{ 1324, 1324 },
	{ 1326, 1326 },
	{ 1329, 1366 },
	{ 4256, 4293 },
	{ 4295, 4295 },
	{ 4301, 4301 },
	{ 5024, 5109 },
	{ 7312, 7354 },
	{ 7357, 7359 },
	{ 7680, 7680 },
	{ 7682, 7682 },
	{ 7684, 7684 },
	{ 7686, 7686 },
	{ 7688, 7688 },
	{ 7690, 7690 },
	{ 7692, 7692 },
	{ 7694, 7694 },
	{ 7696, 7696 },
	{ 7698, 7698 },
	{ 7700, 7700 },
	{ 7702, 7702 },
	{ 7704, 7704 },
	{ 7706, 7706 },
	{ 7708, 7708 },
	{ 7710, 7710 },
	{ 7712, 7712 },
	{ 7714, 7714 },
	{ 7716, 7716 },
	{ 7718, 7718 },
	{ 7720, 7720 },
	{ 7722, 7722 },
	{ 7724, 7724 },
	{ 7726, 7726 },
	{ 7728, 7728 },
	{ 7730, 7730 },
	{ 7732, 7732 },
	{ 7734, 7734 },
	{ 7736, 7736 },
	{ 7738, 7738 },
	{ 7740, 7740 },
	{ 7742, 7742 },
	{ 7744, 7744 },
	{ 7746, 7746 },
	{ 7748, 7748 },
	{ 7750, 7750 },
	{ 7752, 7752 },
	{ 7754, 7754 },
	{ 7756, 7756 },
	{ 7758, 7758 },
	{ 7760, 7760 },
	{ 7762, 7762 },
	{ 7764, 7764 },
	{ 7766, 7766 },
	{ 7768, 7768 },
	{ 7770, 7770 },
	{ 7772, 7772 },
	{ 7774, 7774 },
	{ 7776, 7776 },
	{ 7778, 7778 },
	{ 7780, 7780 },
	{ 7782, 7782 },
	{ 7784, 7784 },
	{ 7786, 7786 },
	{ 7788, 7788 },
	{ 7790, 7790 },
	{ 7792, 7792 },
	{ 7794, 7794 },
	{ 7796, 7796 },
	{ 7798, 7798 },
	{ 7800, 7800 },
	{ 7802, 7802 },
	{ 7804, 7804 },
	{ 7806, 7806 },
	{ 7808, 7808 },
	{ 7810, 7810 },
	{ 7812, 7812 },
	{ 7814, 7814 },
	{ 7816, 7816 },
	{ 7818, 7818 },
	{ 7820, 7820 },
	{ 7822, 7822 },
	{ 7824, 7824 },
	{ 7826, 7826 },
	{ 7828, 7828 },
	{ 7838, 7838 },
	{ 7840, 7840 },
	{ 7842, 7842 },
	{ 7844, 7844 },
	{ 7846, 7846 },
	{ 7848, 7848 },
	{ 7850, 7850 },
	{ 7852, 7852 },
	{ 7854, 7854 },
	{ 7856, 7856 },
	{ 7858, 7858 },
	{ 7860, 7860 },
	{ 7862, 7862 },
	{ 7864, 7864 },
	{ 7866, 7866 },
	{ 7868, 7868 },
	{ 7870, 7870 },
	{ 7872, 7872 },
	{ 7874, 7874 },
	{ 7876, 7876 },
	{ 7878, 7878 },
	{ 7880, 7880 },
	{ 7882, 7882 },
	{ 7884, 7884 },
	{ 7886, 7886 },
	{ 7888, 7888 },
	{ 7890, 7890 },
	{ 7892, 7892 },
	{ 7894, 7894 },
	{ 7896, 7896 },
	{ 7898, 7898 },
	{ 7900, 7900 },
	{ 7902, 7902 },
	{ 7904, 7904 },
	{ 7906, 7906 },
	{ 7908, 7908 },
	{ 7910, 7910 },
	{ 7912, 7912 },
	{ 7914, 7914 },
	{ 7916, 7916 },
	{ 7918, 7918 },
	{ 7920, 7920 },
	{ 7922, 7922 },
	{ 7924, 7924 },
	{ 7926, 7926 },
	{ 7928, 7928 },
	{ 7930, 7930 },
	{ 7932, 7932 },
	{ 7934, 7934 },
	{ 7944, 7951 },
	{ 7960, 7965 },
	{ 7976, 7983 },
	{ 7992, 7999 },
	{ 8008, 8013 },
	{ 8025, 8025 },
	{ 8027, 8027 },
	{ 8029, 8029 },
	{ 8031, 8031 },
	{ 8040, 8047 },
	{ 8072, 8079 },
	{ 8088, 8095 },
	{ 8104, 8111 },
	{ 8120, 8124 },
	{ 8136, 8140 },
	{ 8152, 8155 },
	{ 8168, 8172 },
	{ 8184, 8188 },
	{ 8450, 8450 },
	{ 8455, 8455 },
	{ 8459, 8461 },
	{ 8464, 8466 },
	{ 8469, 8469 },
	{ 8473, 8477 },
	{ 8484, 8484 },
	{ 8486, 8486 },
	{ 8488, 8488 },
	{ 8490, 8493 },
	{ 8496, 8499 },
	{ 8510, 8511 },
	{ 8517, 8517 },
	{ 8544, 8559 },
	{ 8579, 8579 },
	{ 9398, 9423 },
	{ 11264, 11311 },
	{ 11360, 11360 },
	{ 11362, 11364 },
	{ 11367, 11367 },
	{ 11369, 11369 },
	{ 11371, 11371 },
	{ 11373, 11376 },
	{ 11378, 11378 },
	{ 11381, 11381 },
	{ 11390, 11392 },
	{ 11394, 11394 },
	{ 11396, 11396 },
	{ 11398, 11398 },
	{ 11400, 11400 },
	{ 11402, 11402 },
	{ 11404, 11404 },
	{ 11406, 11406 },
	{ 11408, 11408 },
	{ 11410, 11410 },
	{ 11412, 11412 },
	{ 11414, 11414 },
	{ 11416, 11416 },
	{ 11418, 11418 },
	{ 11420, 11420 },
	{ 11422, 11422 },
	{ 11424, 11424 },
	{ 11426, 11426 },
	{ 11428, 11428 },
	{ 11430, 11430 },
	{ 11432, 11432 },
	{ 11434, 11434 },
	{ 11436, 11436 },
	{ 11438, 11438 },
	{ 11440, 11440 },
	{ 11442, 11442 },
	{ 11444, 11444 },
	{ 11446, 11446 },
	{ 11448, 11448 },
	{ 11450, 11450 },
	{ 11452, 11452 },
	{ 11454, 11454 },
	{ 11456, 11456 },
	{ 11458, 11458 },
	{ 11460, 11460 },
	{ 11462, 11462 },
	{ 11464, 11464 },
	{ 11466, 11466 },
	{ 11468, 11468 },
	{ 11470, 11470 },
	{ 11472, 11472 },
	{ 11474, 11474 },
	{ 11476, 11476 },
	{ 11478, 11478 },
	{ 11480, 11480 },
	{ 11482, 11482 },
	{ 11484, 11484 },
	{ 11486, 11486 },
	{ 11488, 11488 },
	{ 11490, 11490 },
	{ 11499, 11499 },
	{ 11501, 11501 },
	{ 11506, 11506 },
	{ 42560, 42560 },
	{ 42562, 42562 },
	{ 42564, 42564 },
	{ 42566, 42566 },
	{ 42568, 42568 },
	{ 42570, 42570 },
	{ 42572, 42572 },
	{ 42574, 42574 },
	{ 42576, 42576 },
	{ 42578, 42578 },
	{ 42580, 42580 },
	{ 42582, 42582 },
	{ 42584, 42584 },
	{ 42586, 42586 },
	{ 42588, 42588 },
	{ 42590, 42590 },
	{ 42592, 42592 },
	{ 42594, 42594 },
	{ 42596, 42596 },
	{ 42598, 42598 },
	{ 42600, 42600 },
	{ 42602, 42602 },
	{ 42604, 42604 },
	{ 42624, 42624 },
	{ 42626, 42626 },
	{ 42628, 42628 },
	{ 42630, 42630 },
	{ 42632, 42632 },
	{ 42634, 42634 },
	{ 42636, 42636 },
	{ 42638, 42638 },
	{ 42640, 42640 },
	{ 42642, 42642 },
	{ 42644, 42644 },
	{ 42646, 42646 },
	{ 42648, 42648 },
	{ 42650, 42650 },
	{ 42786, 42786 },
	{ 42788, 42788 },
	{ 42790, 42790 },
	{ 42792, 42792 },
	{ 42794, 42794 },
	{ 42796, 42796 },
	{ 42798, 42798 },
	{ 42802, 42802 },
	{ 42804, 42804 },
	{ 42806, 42806 },
	{ 42808, 42808 },
	{ 42810, 42810 },
	{ 42812, 42812 },
	{ 42814, 42814 },
	{ 42816, 42816 },
	{ 42818, 42818 },
	{ 42820, 42820 },
	{ 42822, 42822 },
	{ 42824, 42824 },
	{ 42826, 42826 },
	{ 42828, 42828 },
	{ 42830, 42830 },
	{ 42832, 42832 },
	{ 42834, 42834 },
	{ 42836, 42836 },
	{ 42838, 42838 },
	{ 42840, 42840 },
	{ 42842, 42842 },
	{ 42844, 42844 },
	{ 42846, 42846 },
	{ 42848, 42848 },
	{ 42850, 42850 },
	{ 42852, 42852 },
	{ 42854, 42854 },
	{ 42856, 42856 },
	{ 42858, 42858 },
	{ 42860, 42860 },
	{ 42862, 42862 },
	{ 42873, 42873 },
	{ 42875, 42875 },
	{ 42877, 42878 },
	{ 42880, 42880 },
	{ 42882, 42882 },
	{ 42884, 42884 },
	{ 42886, 42886 },
	{ 42891, 42891 },
	{ 42893, 42893 },
	{ 42896, 42896 },
	{ 42898, 42898 },
	{ 42902, 42902 },
	{ 42904, 42904 },
	{ 42906, 42906 },
	{ 42908, 42908 },
	{ 42910, 42910 },
	{ 42912, 42912 },
	{ 42914, 42914 },
	{ 42916, 42916 },
	{ 42918, 42918 },
	{ 42920, 42920 },
	{ 42922, 42926 },
	{ 42928, 42932 },
	{ 42934, 42934 },
	{ 42936, 42936 },
	{ 42938, 42938 },
	{ 42940, 42940 },
	{ 42942, 42942 },
	{ 42944, 42944 },
	{ 42946, 42946 },
	{ 42948, 42951 },
	{ 42953, 42953 },
	{ 42960, 42960 },
	{ 42966, 42966 },
	{ 42968, 42968 },
	{ 42997, 42997 },
	{ 65313, 65338 },
	{ 66560, 66599 },
	{ 66736, 66771 },
	{ 66928, 66938 },
	{ 66940, 66954 },
	{ 66956, 66962 },
	{ 66964, 66965 },
	{ 68736, 68786 },
	{ 71840, 71871 },
	{ 93760, 93791 },
	{ 119808, 119833 },
	{ 119860, 119885 },
	{ 119912, 119937 },
	{ 119964, 119964 },
	{ 119966, 119967 },
	{ 119970, 119970 },
	{ 119973, 119974 },
	{ 119977, 119980 },
	{ 119982, 119989 },
	{ 120016, 120041 },
	{ 120068, 120069 },
	{ 120071, 120074 },
	{ 120077, 120084 },
	{ 120086, 120092 },
	{ 120120, 120121 },
	{ 120123, 120126 },
	{ 120128, 120132 },
	{ 120134, 120134 },
	{ 120138, 120144 },
	{ 120172, 120197 },
	{ 120224, 120249 },
	{ 120276, 120301 },
	{ 120328, 120353 },
	{ 120380, 120405 },
	{ 120432, 120457 },
	{ 120488, 120512 },
	{ 120546, 120570 },
	{ 120604, 120628 },
	{ 120662, 120686 },
	{ 120720, 120744 },
	{ 120778, 120778 },
	{ 125184, 125217 },
	{ 127280, 127305 },
	{ 127312, 127337 },
	{ 127344, 127369 },
@end iftangle
	{ -1, -1 },	// end markers
};
static set_item lower[] = {
	{ 97, 122 },
@ifweave
	...
@end ifweave
@iftangle
	{ 170, 170 },
	{ 181, 181 },
	{ 186, 186 },
	{ 223, 246 },
	{ 248, 255 },
	{ 257, 257 },
	{ 259, 259 },
	{ 261, 261 },
	{ 263, 263 },
	{ 265, 265 },
	{ 267, 267 },
	{ 269, 269 },
	{ 271, 271 },
	{ 273, 273 },
	{ 275, 275 },
	{ 277, 277 },
	{ 279, 279 },
	{ 281, 281 },
	{ 283, 283 },
	{ 285, 285 },
	{ 287, 287 },
	{ 289, 289 },
	{ 291, 291 },
	{ 293, 293 },
	{ 295, 295 },
	{ 297, 297 },
	{ 299, 299 },
	{ 301, 301 },
	{ 303, 303 },
	{ 305, 305 },
	{ 307, 307 },
	{ 309, 309 },
	{ 311, 312 },
	{ 314, 314 },
	{ 316, 316 },
	{ 318, 318 },
	{ 320, 320 },
	{ 322, 322 },
	{ 324, 324 },
	{ 326, 326 },
	{ 328, 329 },
	{ 331, 331 },
	{ 333, 333 },
	{ 335, 335 },
	{ 337, 337 },
	{ 339, 339 },
	{ 341, 341 },
	{ 343, 343 },
	{ 345, 345 },
	{ 347, 347 },
	{ 349, 349 },
	{ 351, 351 },
	{ 353, 353 },
	{ 355, 355 },
	{ 357, 357 },
	{ 359, 359 },
	{ 361, 361 },
	{ 363, 363 },
	{ 365, 365 },
	{ 367, 367 },
	{ 369, 369 },
	{ 371, 371 },
	{ 373, 373 },
	{ 375, 375 },
	{ 378, 378 },
	{ 380, 380 },
	{ 382, 384 },
	{ 387, 387 },
	{ 389, 389 },
	{ 392, 392 },
	{ 396, 397 },
	{ 402, 402 },
	{ 405, 405 },
	{ 409, 411 },
	{ 414, 414 },
	{ 417, 417 },
	{ 419, 419 },
	{ 421, 421 },
	{ 424, 424 },
	{ 426, 427 },
	{ 429, 429 },
	{ 432, 432 },
	{ 436, 436 },
	{ 438, 438 },
	{ 441, 442 },
	{ 445, 447 },
	{ 453, 454 },
	{ 456, 457 },
	{ 459, 460 },
	{ 462, 462 },
	{ 464, 464 },
	{ 466, 466 },
	{ 468, 468 },
	{ 470, 470 },
	{ 472, 472 },
	{ 474, 474 },
	{ 476, 477 },
	{ 479, 479 },
	{ 481, 481 },
	{ 483, 483 },
	{ 485, 485 },
	{ 487, 487 },
	{ 489, 489 },
	{ 491, 491 },
	{ 493, 493 },
	{ 495, 496 },
	{ 498, 499 },
	{ 501, 501 },
	{ 505, 505 },
	{ 507, 507 },
	{ 509, 509 },
	{ 511, 511 },
	{ 513, 513 },
	{ 515, 515 },
	{ 517, 517 },
	{ 519, 519 },
	{ 521, 521 },
	{ 523, 523 },
	{ 525, 525 },
	{ 527, 527 },
	{ 529, 529 },
	{ 531, 531 },
	{ 533, 533 },
	{ 535, 535 },
	{ 537, 537 },
	{ 539, 539 },
	{ 541, 541 },
	{ 543, 543 },
	{ 545, 545 },
	{ 547, 547 },
	{ 549, 549 },
	{ 551, 551 },
	{ 553, 553 },
	{ 555, 555 },
	{ 557, 557 },
	{ 559, 559 },
	{ 561, 561 },
	{ 563, 569 },
	{ 572, 572 },
	{ 575, 576 },
	{ 578, 578 },
	{ 583, 583 },
	{ 585, 585 },
	{ 587, 587 },
	{ 589, 589 },
	{ 591, 659 },
	{ 661, 696 },
	{ 704, 705 },
	{ 736, 740 },
	{ 837, 837 },
	{ 881, 881 },
	{ 883, 883 },
	{ 887, 887 },
	{ 890, 893 },
	{ 912, 912 },
	{ 940, 974 },
	{ 976, 977 },
	{ 981, 983 },
	{ 985, 985 },
	{ 987, 987 },
	{ 989, 989 },
	{ 991, 991 },
	{ 993, 993 },
	{ 995, 995 },
	{ 997, 997 },
	{ 999, 999 },
	{ 1001, 1001 },
	{ 1003, 1003 },
	{ 1005, 1005 },
	{ 1007, 1011 },
	{ 1013, 1013 },
	{ 1016, 1016 },
	{ 1019, 1020 },
	{ 1072, 1119 },
	{ 1121, 1121 },
	{ 1123, 1123 },
	{ 1125, 1125 },
	{ 1127, 1127 },
	{ 1129, 1129 },
	{ 1131, 1131 },
	{ 1133, 1133 },
	{ 1135, 1135 },
	{ 1137, 1137 },
	{ 1139, 1139 },
	{ 1141, 1141 },
	{ 1143, 1143 },
	{ 1145, 1145 },
	{ 1147, 1147 },
	{ 1149, 1149 },
	{ 1151, 1151 },
	{ 1153, 1153 },
	{ 1163, 1163 },
	{ 1165, 1165 },
	{ 1167, 1167 },
	{ 1169, 1169 },
	{ 1171, 1171 },
	{ 1173, 1173 },
	{ 1175, 1175 },
	{ 1177, 1177 },
	{ 1179, 1179 },
	{ 1181, 1181 },
	{ 1183, 1183 },
	{ 1185, 1185 },
	{ 1187, 1187 },
	{ 1189, 1189 },
	{ 1191, 1191 },
	{ 1193, 1193 },
	{ 1195, 1195 },
	{ 1197, 1197 },
	{ 1199, 1199 },
	{ 1201, 1201 },
	{ 1203, 1203 },
	{ 1205, 1205 },
	{ 1207, 1207 },
	{ 1209, 1209 },
	{ 1211, 1211 },
	{ 1213, 1213 },
	{ 1215, 1215 },
	{ 1218, 1218 },
	{ 1220, 1220 },
	{ 1222, 1222 },
	{ 1224, 1224 },
	{ 1226, 1226 },
	{ 1228, 1228 },
	{ 1230, 1231 },
	{ 1233, 1233 },
	{ 1235, 1235 },
	{ 1237, 1237 },
	{ 1239, 1239 },
	{ 1241, 1241 },
	{ 1243, 1243 },
	{ 1245, 1245 },
	{ 1247, 1247 },
	{ 1249, 1249 },
	{ 1251, 1251 },
	{ 1253, 1253 },
	{ 1255, 1255 },
	{ 1257, 1257 },
	{ 1259, 1259 },
	{ 1261, 1261 },
	{ 1263, 1263 },
	{ 1265, 1265 },
	{ 1267, 1267 },
	{ 1269, 1269 },
	{ 1271, 1271 },
	{ 1273, 1273 },
	{ 1275, 1275 },
	{ 1277, 1277 },
	{ 1279, 1279 },
	{ 1281, 1281 },
	{ 1283, 1283 },
	{ 1285, 1285 },
	{ 1287, 1287 },
	{ 1289, 1289 },
	{ 1291, 1291 },
	{ 1293, 1293 },
	{ 1295, 1295 },
	{ 1297, 1297 },
	{ 1299, 1299 },
	{ 1301, 1301 },
	{ 1303, 1303 },
	{ 1305, 1305 },
	{ 1307, 1307 },
	{ 1309, 1309 },
	{ 1311, 1311 },
	{ 1313, 1313 },
	{ 1315, 1315 },
	{ 1317, 1317 },
	{ 1319, 1319 },
	{ 1321, 1321 },
	{ 1323, 1323 },
	{ 1325, 1325 },
	{ 1327, 1327 },
	{ 1376, 1416 },
	{ 4304, 4346 },
	{ 4349, 4351 },
	{ 5112, 5117 },
	{ 7296, 7304 },
	{ 7424, 7615 },
	{ 7681, 7681 },
	{ 7683, 7683 },
	{ 7685, 7685 },
	{ 7687, 7687 },
	{ 7689, 7689 },
	{ 7691, 7691 },
	{ 7693, 7693 },
	{ 7695, 7695 },
	{ 7697, 7697 },
	{ 7699, 7699 },
	{ 7701, 7701 },
	{ 7703, 7703 },
	{ 7705, 7705 },
	{ 7707, 7707 },
	{ 7709, 7709 },
	{ 7711, 7711 },
	{ 7713, 7713 },
	{ 7715, 7715 },
	{ 7717, 7717 },
	{ 7719, 7719 },
	{ 7721, 7721 },
	{ 7723, 7723 },
	{ 7725, 7725 },
	{ 7727, 7727 },
	{ 7729, 7729 },
	{ 7731, 7731 },
	{ 7733, 7733 },
	{ 7735, 7735 },
	{ 7737, 7737 },
	{ 7739, 7739 },
	{ 7741, 7741 },
	{ 7743, 7743 },
	{ 7745, 7745 },
	{ 7747, 7747 },
	{ 7749, 7749 },
	{ 7751, 7751 },
	{ 7753, 7753 },
	{ 7755, 7755 },
	{ 7757, 7757 },
	{ 7759, 7759 },
	{ 7761, 7761 },
	{ 7763, 7763 },
	{ 7765, 7765 },
	{ 7767, 7767 },
	{ 7769, 7769 },
	{ 7771, 7771 },
	{ 7773, 7773 },
	{ 7775, 7775 },
	{ 7777, 7777 },
	{ 7779, 7779 },
	{ 7781, 7781 },
	{ 7783, 7783 },
	{ 7785, 7785 },
	{ 7787, 7787 },
	{ 7789, 7789 },
	{ 7791, 7791 },
	{ 7793, 7793 },
	{ 7795, 7795 },
	{ 7797, 7797 },
	{ 7799, 7799 },
	{ 7801, 7801 },
	{ 7803, 7803 },
	{ 7805, 7805 },
	{ 7807, 7807 },
	{ 7809, 7809 },
	{ 7811, 7811 },
	{ 7813, 7813 },
	{ 7815, 7815 },
	{ 7817, 7817 },
	{ 7819, 7819 },
	{ 7821, 7821 },
	{ 7823, 7823 },
	{ 7825, 7825 },
	{ 7827, 7827 },
	{ 7829, 7837 },
	{ 7839, 7839 },
	{ 7841, 7841 },
	{ 7843, 7843 },
	{ 7845, 7845 },
	{ 7847, 7847 },
	{ 7849, 7849 },
	{ 7851, 7851 },
	{ 7853, 7853 },
	{ 7855, 7855 },
	{ 7857, 7857 },
	{ 7859, 7859 },
	{ 7861, 7861 },
	{ 7863, 7863 },
	{ 7865, 7865 },
	{ 7867, 7867 },
	{ 7869, 7869 },
	{ 7871, 7871 },
	{ 7873, 7873 },
	{ 7875, 7875 },
	{ 7877, 7877 },
	{ 7879, 7879 },
	{ 7881, 7881 },
	{ 7883, 7883 },
	{ 7885, 7885 },
	{ 7887, 7887 },
	{ 7889, 7889 },
	{ 7891, 7891 },
	{ 7893, 7893 },
	{ 7895, 7895 },
	{ 7897, 7897 },
	{ 7899, 7899 },
	{ 7901, 7901 },
	{ 7903, 7903 },
	{ 7905, 7905 },
	{ 7907, 7907 },
	{ 7909, 7909 },
	{ 7911, 7911 },
	{ 7913, 7913 },
	{ 7915, 7915 },
	{ 7917, 7917 },
	{ 7919, 7919 },
	{ 7921, 7921 },
	{ 7923, 7923 },
	{ 7925, 7925 },
	{ 7927, 7927 },
	{ 7929, 7929 },
	{ 7931, 7931 },
	{ 7933, 7933 },
	{ 7935, 7943 },
	{ 7952, 7957 },
	{ 7968, 7975 },
	{ 7984, 7991 },
	{ 8000, 8005 },
	{ 8016, 8023 },
	{ 8032, 8039 },
	{ 8048, 8061 },
	{ 8064, 8071 },
	{ 8080, 8087 },
	{ 8096, 8103 },
	{ 8112, 8116 },
	{ 8118, 8119 },
	{ 8126, 8126 },
	{ 8130, 8132 },
	{ 8134, 8135 },
	{ 8144, 8147 },
	{ 8150, 8151 },
	{ 8160, 8167 },
	{ 8178, 8180 },
	{ 8182, 8183 },
	{ 8305, 8305 },
	{ 8319, 8319 },
	{ 8336, 8348 },
	{ 8458, 8458 },
	{ 8462, 8463 },
	{ 8467, 8467 },
	{ 8495, 8495 },
	{ 8500, 8500 },
	{ 8505, 8505 },
	{ 8508, 8509 },
	{ 8518, 8521 },
	{ 8526, 8526 },
	{ 8560, 8575 },
	{ 8580, 8580 },
	{ 9424, 9449 },
	{ 11312, 11359 },
	{ 11361, 11361 },
	{ 11365, 11366 },
	{ 11368, 11368 },
	{ 11370, 11370 },
	{ 11372, 11372 },
	{ 11377, 11377 },
	{ 11379, 11380 },
	{ 11382, 11389 },
	{ 11393, 11393 },
	{ 11395, 11395 },
	{ 11397, 11397 },
	{ 11399, 11399 },
	{ 11401, 11401 },
	{ 11403, 11403 },
	{ 11405, 11405 },
	{ 11407, 11407 },
	{ 11409, 11409 },
	{ 11411, 11411 },
	{ 11413, 11413 },
	{ 11415, 11415 },
	{ 11417, 11417 },
	{ 11419, 11419 },
	{ 11421, 11421 },
	{ 11423, 11423 },
	{ 11425, 11425 },
	{ 11427, 11427 },
	{ 11429, 11429 },
	{ 11431, 11431 },
	{ 11433, 11433 },
	{ 11435, 11435 },
	{ 11437, 11437 },
	{ 11439, 11439 },
	{ 11441, 11441 },
	{ 11443, 11443 },
	{ 11445, 11445 },
	{ 11447, 11447 },
	{ 11449, 11449 },
	{ 11451, 11451 },
	{ 11453, 11453 },
	{ 11455, 11455 },
	{ 11457, 11457 },
	{ 11459, 11459 },
	{ 11461, 11461 },
	{ 11463, 11463 },
	{ 11465, 11465 },
	{ 11467, 11467 },
	{ 11469, 11469 },
	{ 11471, 11471 },
	{ 11473, 11473 },
	{ 11475, 11475 },
	{ 11477, 11477 },
	{ 11479, 11479 },
	{ 11481, 11481 },
	{ 11483, 11483 },
	{ 11485, 11485 },
	{ 11487, 11487 },
	{ 11489, 11489 },
	{ 11491, 11492 },
	{ 11500, 11500 },
	{ 11502, 11502 },
	{ 11507, 11507 },
	{ 11520, 11557 },
	{ 11559, 11559 },
	{ 11565, 11565 },
	{ 42561, 42561 },
	{ 42563, 42563 },
	{ 42565, 42565 },
	{ 42567, 42567 },
	{ 42569, 42569 },
	{ 42571, 42571 },
	{ 42573, 42573 },
	{ 42575, 42575 },
	{ 42577, 42577 },
	{ 42579, 42579 },
	{ 42581, 42581 },
	{ 42583, 42583 },
	{ 42585, 42585 },
	{ 42587, 42587 },
	{ 42589, 42589 },
	{ 42591, 42591 },
	{ 42593, 42593 },
	{ 42595, 42595 },
	{ 42597, 42597 },
	{ 42599, 42599 },
	{ 42601, 42601 },
	{ 42603, 42603 },
	{ 42605, 42605 },
	{ 42625, 42625 },
	{ 42627, 42627 },
	{ 42629, 42629 },
	{ 42631, 42631 },
	{ 42633, 42633 },
	{ 42635, 42635 },
	{ 42637, 42637 },
	{ 42639, 42639 },
	{ 42641, 42641 },
	{ 42643, 42643 },
	{ 42645, 42645 },
	{ 42647, 42647 },
	{ 42649, 42649 },
	{ 42651, 42653 },
	{ 42787, 42787 },
	{ 42789, 42789 },
	{ 42791, 42791 },
	{ 42793, 42793 },
	{ 42795, 42795 },
	{ 42797, 42797 },
	{ 42799, 42801 },
	{ 42803, 42803 },
	{ 42805, 42805 },
	{ 42807, 42807 },
	{ 42809, 42809 },
	{ 42811, 42811 },
	{ 42813, 42813 },
	{ 42815, 42815 },
	{ 42817, 42817 },
	{ 42819, 42819 },
	{ 42821, 42821 },
	{ 42823, 42823 },
	{ 42825, 42825 },
	{ 42827, 42827 },
	{ 42829, 42829 },
	{ 42831, 42831 },
	{ 42833, 42833 },
	{ 42835, 42835 },
	{ 42837, 42837 },
	{ 42839, 42839 },
	{ 42841, 42841 },
	{ 42843, 42843 },
	{ 42845, 42845 },
	{ 42847, 42847 },
	{ 42849, 42849 },
	{ 42851, 42851 },
	{ 42853, 42853 },
	{ 42855, 42855 },
	{ 42857, 42857 },
	{ 42859, 42859 },
	{ 42861, 42861 },
	{ 42863, 42872 },
	{ 42874, 42874 },
	{ 42876, 42876 },
	{ 42879, 42879 },
	{ 42881, 42881 },
	{ 42883, 42883 },
	{ 42885, 42885 },
	{ 42887, 42887 },
	{ 42892, 42892 },
	{ 42894, 42894 },
	{ 42897, 42897 },
	{ 42899, 42901 },
	{ 42903, 42903 },
	{ 42905, 42905 },
	{ 42907, 42907 },
	{ 42909, 42909 },
	{ 42911, 42911 },
	{ 42913, 42913 },
	{ 42915, 42915 },
	{ 42917, 42917 },
	{ 42919, 42919 },
	{ 42921, 42921 },
	{ 42927, 42927 },
	{ 42933, 42933 },
	{ 42935, 42935 },
	{ 42937, 42937 },
	{ 42939, 42939 },
	{ 42941, 42941 },
	{ 42943, 42943 },
	{ 42945, 42945 },
	{ 42947, 42947 },
	{ 42952, 42952 },
	{ 42954, 42954 },
	{ 42961, 42961 },
	{ 42963, 42963 },
	{ 42965, 42965 },
	{ 42967, 42967 },
	{ 42969, 42969 },
	{ 42998, 42998 },
	{ 43000, 43002 },
	{ 43824, 43866 },
	{ 43868, 43880 },
	{ 43888, 43967 },
	{ 64256, 64262 },
	{ 64275, 64279 },
	{ 65345, 65370 },
	{ 66600, 66639 },
	{ 66776, 66811 },
	{ 66967, 66977 },
	{ 66979, 66993 },
	{ 66995, 67001 },
	{ 67003, 67004 },
	{ 67456, 67456 },
	{ 67459, 67461 },
	{ 67463, 67504 },
	{ 67506, 67514 },
	{ 68800, 68850 },
	{ 71872, 71903 },
	{ 93792, 93823 },
	{ 119834, 119859 },
	{ 119886, 119892 },
	{ 119894, 119911 },
	{ 119938, 119963 },
	{ 119990, 119993 },
	{ 119995, 119995 },
	{ 119997, 120003 },
	{ 120005, 120015 },
	{ 120042, 120067 },
	{ 120094, 120119 },
	{ 120146, 120171 },
	{ 120198, 120223 },
	{ 120250, 120275 },
	{ 120302, 120327 },
	{ 120354, 120379 },
	{ 120406, 120431 },
	{ 120458, 120485 },
	{ 120514, 120538 },
	{ 120540, 120545 },
	{ 120572, 120596 },
	{ 120598, 120603 },
	{ 120630, 120654 },
	{ 120656, 120661 },
	{ 120688, 120712 },
	{ 120714, 120719 },
	{ 120746, 120770 },
	{ 120772, 120777 },
	{ 120779, 120779 },
	{ 122624, 122633 },
	{ 122635, 122654 },
	{ 125218, 125251 },
@end iftangle
	{ -1, -1 },	// end markers
};
static set_item print_graph_common[] = {
	{ 160, 887 },
@ifweave
	...
@end ifweave
@iftangle
	{ 890, 895 },
	{ 900, 906 },
	{ 908, 908 },
	{ 910, 929 },
	{ 931, 1327 },
	{ 1329, 1366 },
	{ 1369, 1418 },
	{ 1421, 1423 },
	{ 1425, 1479 },
	{ 1488, 1514 },
	{ 1519, 1524 },
	{ 1536, 1805 },
	{ 1807, 1866 },
	{ 1869, 1969 },
	{ 1984, 2042 },
	{ 2045, 2093 },
	{ 2096, 2110 },
	{ 2112, 2139 },
	{ 2142, 2142 },
	{ 2144, 2154 },
	{ 2160, 2190 },
	{ 2192, 2193 },
	{ 2200, 2435 },
	{ 2437, 2444 },
	{ 2447, 2448 },
	{ 2451, 2472 },
	{ 2474, 2480 },
	{ 2482, 2482 },
	{ 2486, 2489 },
	{ 2492, 2500 },
	{ 2503, 2504 },
	{ 2507, 2510 },
	{ 2519, 2519 },
	{ 2524, 2525 },
	{ 2527, 2531 },
	{ 2534, 2558 },
	{ 2561, 2563 },
	{ 2565, 2570 },
	{ 2575, 2576 },
	{ 2579, 2600 },
	{ 2602, 2608 },
	{ 2610, 2611 },
	{ 2613, 2614 },
	{ 2616, 2617 },
	{ 2620, 2620 },
	{ 2622, 2626 },
	{ 2631, 2632 },
	{ 2635, 2637 },
	{ 2641, 2641 },
	{ 2649, 2652 },
	{ 2654, 2654 },
	{ 2662, 2678 },
	{ 2689, 2691 },
	{ 2693, 2701 },
	{ 2703, 2705 },
	{ 2707, 2728 },
	{ 2730, 2736 },
	{ 2738, 2739 },
	{ 2741, 2745 },
	{ 2748, 2757 },
	{ 2759, 2761 },
	{ 2763, 2765 },
	{ 2768, 2768 },
	{ 2784, 2787 },
	{ 2790, 2801 },
	{ 2809, 2815 },
	{ 2817, 2819 },
	{ 2821, 2828 },
	{ 2831, 2832 },
	{ 2835, 2856 },
	{ 2858, 2864 },
	{ 2866, 2867 },
	{ 2869, 2873 },
	{ 2876, 2884 },
	{ 2887, 2888 },
	{ 2891, 2893 },
	{ 2901, 2903 },
	{ 2908, 2909 },
	{ 2911, 2915 },
	{ 2918, 2935 },
	{ 2946, 2947 },
	{ 2949, 2954 },
	{ 2958, 2960 },
	{ 2962, 2965 },
	{ 2969, 2970 },
	{ 2972, 2972 },
	{ 2974, 2975 },
	{ 2979, 2980 },
	{ 2984, 2986 },
	{ 2990, 3001 },
	{ 3006, 3010 },
	{ 3014, 3016 },
	{ 3018, 3021 },
	{ 3024, 3024 },
	{ 3031, 3031 },
	{ 3046, 3066 },
	{ 3072, 3084 },
	{ 3086, 3088 },
	{ 3090, 3112 },
	{ 3114, 3129 },
	{ 3132, 3140 },
	{ 3142, 3144 },
	{ 3146, 3149 },
	{ 3157, 3158 },
	{ 3160, 3162 },
	{ 3165, 3165 },
	{ 3168, 3171 },
	{ 3174, 3183 },
	{ 3191, 3212 },
	{ 3214, 3216 },
	{ 3218, 3240 },
	{ 3242, 3251 },
	{ 3253, 3257 },
	{ 3260, 3268 },
	{ 3270, 3272 },
	{ 3274, 3277 },
	{ 3285, 3286 },
	{ 3293, 3294 },
	{ 3296, 3299 },
	{ 3302, 3311 },
	{ 3313, 3314 },
	{ 3328, 3340 },
	{ 3342, 3344 },
	{ 3346, 3396 },
	{ 3398, 3400 },
	{ 3402, 3407 },
	{ 3412, 3427 },
	{ 3430, 3455 },
	{ 3457, 3459 },
	{ 3461, 3478 },
	{ 3482, 3505 },
	{ 3507, 3515 },
	{ 3517, 3517 },
	{ 3520, 3526 },
	{ 3530, 3530 },
	{ 3535, 3540 },
	{ 3542, 3542 },
	{ 3544, 3551 },
	{ 3558, 3567 },
	{ 3570, 3572 },
	{ 3585, 3642 },
	{ 3647, 3675 },
	{ 3713, 3714 },
	{ 3716, 3716 },
	{ 3718, 3722 },
	{ 3724, 3747 },
	{ 3749, 3749 },
	{ 3751, 3773 },
	{ 3776, 3780 },
	{ 3782, 3782 },
	{ 3784, 3789 },
	{ 3792, 3801 },
	{ 3804, 3807 },
	{ 3840, 3911 },
	{ 3913, 3948 },
	{ 3953, 3991 },
	{ 3993, 4028 },
	{ 4030, 4044 },
	{ 4046, 4058 },
	{ 4096, 4293 },
	{ 4295, 4295 },
	{ 4301, 4301 },
	{ 4304, 4680 },
	{ 4682, 4685 },
	{ 4688, 4694 },
	{ 4696, 4696 },
	{ 4698, 4701 },
	{ 4704, 4744 },
	{ 4746, 4749 },
	{ 4752, 4784 },
	{ 4786, 4789 },
	{ 4792, 4798 },
	{ 4800, 4800 },
	{ 4802, 4805 },
	{ 4808, 4822 },
	{ 4824, 4880 },
	{ 4882, 4885 },
	{ 4888, 4954 },
	{ 4957, 4988 },
	{ 4992, 5017 },
	{ 5024, 5109 },
	{ 5112, 5117 },
	{ 5792, 5880 },
	{ 5888, 5909 },
	{ 5919, 5942 },
	{ 5952, 5971 },
	{ 5984, 5996 },
	{ 5998, 6000 },
	{ 6002, 6003 },
	{ 6016, 6109 },
	{ 6112, 6121 },
	{ 6128, 6137 },
	{ 6144, 6169 },
	{ 6176, 6264 },
	{ 6272, 6314 },
	{ 6320, 6389 },
	{ 6400, 6430 },
	{ 6432, 6443 },
	{ 6448, 6459 },
	{ 6464, 6464 },
	{ 6468, 6509 },
	{ 6512, 6516 },
	{ 6528, 6571 },
	{ 6576, 6601 },
	{ 6608, 6618 },
	{ 6622, 6683 },
	{ 6686, 6750 },
	{ 6752, 6780 },
	{ 6783, 6793 },
	{ 6800, 6809 },
	{ 6816, 6829 },
	{ 6832, 6862 },
	{ 6912, 6988 },
	{ 6992, 7038 },
	{ 7040, 7155 },
	{ 7164, 7223 },
	{ 7227, 7241 },
	{ 7245, 7304 },
	{ 7312, 7354 },
	{ 7357, 7367 },
	{ 7376, 7418 },
	{ 7424, 7957 },
	{ 7960, 7965 },
	{ 7968, 8005 },
	{ 8008, 8013 },
	{ 8016, 8023 },
	{ 8025, 8025 },
	{ 8027, 8027 },
	{ 8029, 8029 },
	{ 8031, 8061 },
	{ 8064, 8116 },
	{ 8118, 8132 },
	{ 8134, 8147 },
	{ 8150, 8155 },
	{ 8157, 8175 },
	{ 8178, 8180 },
	{ 8182, 8190 },
	{ 8294, 8305 },
	{ 8308, 8334 },
	{ 8336, 8348 },
	{ 8352, 8384 },
	{ 8400, 8432 },
	{ 8448, 8587 },
	{ 8592, 9254 },
	{ 9280, 9290 },
	{ 9312, 11123 },
	{ 11126, 11157 },
	{ 11159, 11507 },
	{ 11513, 11557 },
	{ 11559, 11559 },
	{ 11565, 11565 },
	{ 11568, 11623 },
	{ 11631, 11632 },
	{ 11647, 11670 },
	{ 11680, 11686 },
	{ 11688, 11694 },
	{ 11696, 11702 },
	{ 11704, 11710 },
	{ 11712, 11718 },
	{ 11720, 11726 },
	{ 11728, 11734 },
	{ 11736, 11742 },
	{ 11744, 11869 },
	{ 11904, 11929 },
	{ 11931, 12019 },
	{ 12032, 12245 },
	{ 12272, 12283 },
	{ 12353, 12438 },
	{ 12441, 12543 },
	{ 12549, 12591 },
	{ 12593, 12686 },
	{ 12688, 12771 },
	{ 12784, 12830 },
	{ 12832, 42124 },
	{ 42128, 42182 },
	{ 42192, 42539 },
	{ 42560, 42743 },
	{ 42752, 42954 },
	{ 42960, 42961 },
	{ 42963, 42963 },
	{ 42965, 42969 },
	{ 42994, 43052 },
	{ 43056, 43065 },
	{ 43072, 43127 },
	{ 43136, 43205 },
	{ 43214, 43225 },
	{ 43232, 43347 },
	{ 43359, 43388 },
	{ 43392, 43469 },
	{ 43471, 43481 },
	{ 43486, 43518 },
	{ 43520, 43574 },
	{ 43584, 43597 },
	{ 43600, 43609 },
	{ 43612, 43714 },
	{ 43739, 43766 },
	{ 43777, 43782 },
	{ 43785, 43790 },
	{ 43793, 43798 },
	{ 43808, 43814 },
	{ 43816, 43822 },
	{ 43824, 43883 },
	{ 43888, 44013 },
	{ 44016, 44025 },
	{ 44032, 55203 },
	{ 55216, 55238 },
	{ 55243, 55291 },
	{ 57344, 64109 },
	{ 64112, 64217 },
	{ 64256, 64262 },
	{ 64275, 64279 },
	{ 64285, 64310 },
	{ 64312, 64316 },
	{ 64318, 64318 },
	{ 64320, 64321 },
	{ 64323, 64324 },
	{ 64326, 64450 },
	{ 64467, 64911 },
	{ 64914, 64967 },
	{ 64975, 64975 },
	{ 65008, 65049 },
	{ 65056, 65106 },
	{ 65108, 65126 },
	{ 65128, 65131 },
	{ 65136, 65140 },
	{ 65142, 65276 },
	{ 65279, 65279 },
	{ 65281, 65470 },
	{ 65474, 65479 },
	{ 65482, 65487 },
	{ 65490, 65495 },
	{ 65498, 65500 },
	{ 65504, 65510 },
	{ 65512, 65518 },
	{ 65529, 65533 },
	{ 65536, 65547 },
	{ 65549, 65574 },
	{ 65576, 65594 },
	{ 65596, 65597 },
	{ 65599, 65613 },
	{ 65616, 65629 },
	{ 65664, 65786 },
	{ 65792, 65794 },
	{ 65799, 65843 },
	{ 65847, 65934 },
	{ 65936, 65948 },
	{ 65952, 65952 },
	{ 66000, 66045 },
	{ 66176, 66204 },
	{ 66208, 66256 },
	{ 66272, 66299 },
	{ 66304, 66339 },
	{ 66349, 66378 },
	{ 66384, 66426 },
	{ 66432, 66461 },
	{ 66463, 66499 },
	{ 66504, 66517 },
	{ 66560, 66717 },
	{ 66720, 66729 },
	{ 66736, 66771 },
	{ 66776, 66811 },
	{ 66816, 66855 },
	{ 66864, 66915 },
	{ 66927, 66938 },
	{ 66940, 66954 },
	{ 66956, 66962 },
	{ 66964, 66965 },
	{ 66967, 66977 },
	{ 66979, 66993 },
	{ 66995, 67001 },
	{ 67003, 67004 },
	{ 67072, 67382 },
	{ 67392, 67413 },
	{ 67424, 67431 },
	{ 67456, 67461 },
	{ 67463, 67504 },
	{ 67506, 67514 },
	{ 67584, 67589 },
	{ 67592, 67592 },
	{ 67594, 67637 },
	{ 67639, 67640 },
	{ 67644, 67644 },
	{ 67647, 67669 },
	{ 67671, 67742 },
	{ 67751, 67759 },
	{ 67808, 67826 },
	{ 67828, 67829 },
	{ 67835, 67867 },
	{ 67871, 67897 },
	{ 67903, 67903 },
	{ 67968, 68023 },
	{ 68028, 68047 },
	{ 68050, 68099 },
	{ 68101, 68102 },
	{ 68108, 68115 },
	{ 68117, 68119 },
	{ 68121, 68149 },
	{ 68152, 68154 },
	{ 68159, 68168 },
	{ 68176, 68184 },
	{ 68192, 68255 },
	{ 68288, 68326 },
	{ 68331, 68342 },
	{ 68352, 68405 },
	{ 68409, 68437 },
	{ 68440, 68466 },
	{ 68472, 68497 },
	{ 68505, 68508 },
	{ 68521, 68527 },
	{ 68608, 68680 },
	{ 68736, 68786 },
	{ 68800, 68850 },
	{ 68858, 68903 },
	{ 68912, 68921 },
	{ 69216, 69246 },
	{ 69248, 69289 },
	{ 69291, 69293 },
	{ 69296, 69297 },
	{ 69376, 69415 },
	{ 69424, 69465 },
	{ 69488, 69513 },
	{ 69552, 69579 },
	{ 69600, 69622 },
	{ 69632, 69709 },
	{ 69714, 69749 },
	{ 69759, 69826 },
	{ 69837, 69837 },
	{ 69840, 69864 },
	{ 69872, 69881 },
	{ 69888, 69940 },
	{ 69942, 69959 },
	{ 69968, 70006 },
	{ 70016, 70111 },
	{ 70113, 70132 },
	{ 70144, 70161 },
	{ 70163, 70206 },
	{ 70272, 70278 },
	{ 70280, 70280 },
	{ 70282, 70285 },
	{ 70287, 70301 },
	{ 70303, 70313 },
	{ 70320, 70378 },
	{ 70384, 70393 },
	{ 70400, 70403 },
	{ 70405, 70412 },
	{ 70415, 70416 },
	{ 70419, 70440 },
	{ 70442, 70448 },
	{ 70450, 70451 },
	{ 70453, 70457 },
	{ 70459, 70468 },
	{ 70471, 70472 },
	{ 70475, 70477 },
	{ 70480, 70480 },
	{ 70487, 70487 },
	{ 70493, 70499 },
	{ 70502, 70508 },
	{ 70512, 70516 },
	{ 70656, 70747 },
	{ 70749, 70753 },
	{ 70784, 70855 },
	{ 70864, 70873 },
	{ 71040, 71093 },
	{ 71096, 71133 },
	{ 71168, 71236 },
	{ 71248, 71257 },
	{ 71264, 71276 },
	{ 71296, 71353 },
	{ 71360, 71369 },
	{ 71424, 71450 },
	{ 71453, 71467 },
	{ 71472, 71494 },
	{ 71680, 71739 },
	{ 71840, 71922 },
	{ 71935, 71942 },
	{ 71945, 71945 },
	{ 71948, 71955 },
	{ 71957, 71958 },
	{ 71960, 71989 },
	{ 71991, 71992 },
	{ 71995, 72006 },
	{ 72016, 72025 },
	{ 72096, 72103 },
	{ 72106, 72151 },
	{ 72154, 72164 },
	{ 72192, 72263 },
	{ 72272, 72354 },
	{ 72368, 72440 },
	{ 72704, 72712 },
	{ 72714, 72758 },
	{ 72760, 72773 },
	{ 72784, 72812 },
	{ 72816, 72847 },
	{ 72850, 72871 },
	{ 72873, 72886 },
	{ 72960, 72966 },
	{ 72968, 72969 },
	{ 72971, 73014 },
	{ 73018, 73018 },
	{ 73020, 73021 },
	{ 73023, 73031 },
	{ 73040, 73049 },
	{ 73056, 73061 },
	{ 73063, 73064 },
	{ 73066, 73102 },
	{ 73104, 73105 },
	{ 73107, 73112 },
	{ 73120, 73129 },
	{ 73440, 73464 },
	{ 73648, 73648 },
	{ 73664, 73713 },
	{ 73727, 74649 },
	{ 74752, 74862 },
	{ 74864, 74868 },
	{ 74880, 75075 },
	{ 77712, 77810 },
	{ 77824, 78894 },
	{ 78896, 78904 },
	{ 82944, 83526 },
	{ 92160, 92728 },
	{ 92736, 92766 },
	{ 92768, 92777 },
	{ 92782, 92862 },
	{ 92864, 92873 },
	{ 92880, 92909 },
	{ 92912, 92917 },
	{ 92928, 92997 },
	{ 93008, 93017 },
	{ 93019, 93025 },
	{ 93027, 93047 },
	{ 93053, 93071 },
	{ 93760, 93850 },
	{ 93952, 94026 },
	{ 94031, 94087 },
	{ 94095, 94111 },
	{ 94176, 94180 },
	{ 94192, 94193 },
	{ 94208, 100343 },
	{ 100352, 101589 },
	{ 101632, 101640 },
	{ 110576, 110579 },
	{ 110581, 110587 },
	{ 110589, 110590 },
	{ 110592, 110882 },
	{ 110928, 110930 },
	{ 110948, 110951 },
	{ 110960, 111355 },
	{ 113664, 113770 },
	{ 113776, 113788 },
	{ 113792, 113800 },
	{ 113808, 113817 },
	{ 113820, 113827 },
	{ 118528, 118573 },
	{ 118576, 118598 },
	{ 118608, 118723 },
	{ 118784, 119029 },
	{ 119040, 119078 },
	{ 119081, 119274 },
	{ 119296, 119365 },
	{ 119520, 119539 },
	{ 119552, 119638 },
	{ 119648, 119672 },
	{ 119808, 119892 },
	{ 119894, 119964 },
	{ 119966, 119967 },
	{ 119970, 119970 },
	{ 119973, 119974 },
	{ 119977, 119980 },
	{ 119982, 119993 },
	{ 119995, 119995 },
	{ 119997, 120003 },
	{ 120005, 120069 },
	{ 120071, 120074 },
	{ 120077, 120084 },
	{ 120086, 120092 },
	{ 120094, 120121 },
	{ 120123, 120126 },
	{ 120128, 120132 },
	{ 120134, 120134 },
	{ 120138, 120144 },
	{ 120146, 120485 },
	{ 120488, 120779 },
	{ 120782, 121483 },
	{ 121499, 121503 },
	{ 121505, 121519 },
	{ 122624, 122654 },
	{ 122880, 122886 },
	{ 122888, 122904 },
	{ 122907, 122913 },
	{ 122915, 122916 },
	{ 122918, 122922 },
	{ 123136, 123180 },
	{ 123184, 123197 },
	{ 123200, 123209 },
	{ 123214, 123215 },
	{ 123536, 123566 },
	{ 123584, 123641 },
	{ 123647, 123647 },
	{ 124896, 124902 },
	{ 124904, 124907 },
	{ 124909, 124910 },
	{ 124912, 124926 },
	{ 124928, 125124 },
	{ 125127, 125142 },
	{ 125184, 125259 },
	{ 125264, 125273 },
	{ 125278, 125279 },
	{ 126065, 126132 },
	{ 126209, 126269 },
	{ 126464, 126467 },
	{ 126469, 126495 },
	{ 126497, 126498 },
	{ 126500, 126500 },
	{ 126503, 126503 },
	{ 126505, 126514 },
	{ 126516, 126519 },
	{ 126521, 126521 },
	{ 126523, 126523 },
	{ 126530, 126530 },
	{ 126535, 126535 },
	{ 126537, 126537 },
	{ 126539, 126539 },
	{ 126541, 126543 },
	{ 126545, 126546 },
	{ 126548, 126548 },
	{ 126551, 126551 },
	{ 126553, 126553 },
	{ 126555, 126555 },
	{ 126557, 126557 },
	{ 126559, 126559 },
	{ 126561, 126562 },
	{ 126564, 126564 },
	{ 126567, 126570 },
	{ 126572, 126578 },
	{ 126580, 126583 },
	{ 126585, 126588 },
	{ 126590, 126590 },
	{ 126592, 126601 },
	{ 126603, 126619 },
	{ 126625, 126627 },
	{ 126629, 126633 },
	{ 126635, 126651 },
	{ 126704, 126705 },
	{ 126976, 127019 },
	{ 127024, 127123 },
	{ 127136, 127150 },
	{ 127153, 127167 },
	{ 127169, 127183 },
	{ 127185, 127221 },
	{ 127232, 127405 },
	{ 127462, 127490 },
	{ 127504, 127547 },
	{ 127552, 127560 },
	{ 127568, 127569 },
	{ 127584, 127589 },
	{ 127744, 128727 },
	{ 128733, 128748 },
	{ 128752, 128764 },
	{ 128768, 128883 },
	{ 128896, 128984 },
	{ 128992, 129003 },
	{ 129008, 129008 },
	{ 129024, 129035 },
	{ 129040, 129095 },
	{ 129104, 129113 },
	{ 129120, 129159 },
	{ 129168, 129197 },
	{ 129200, 129201 },
	{ 129280, 129619 },
	{ 129632, 129645 },
	{ 129648, 129652 },
	{ 129656, 129660 },
	{ 129664, 129670 },
	{ 129680, 129708 },
	{ 129712, 129722 },
	{ 129728, 129733 },
	{ 129744, 129753 },
	{ 129760, 129767 },
	{ 129776, 129782 },
	{ 129792, 129938 },
	{ 129940, 129994 },
	{ 130032, 130041 },
	{ 131072, 173791 },
	{ 173824, 177976 },
	{ 177984, 178205 },
	{ 178208, 183969 },
	{ 183984, 191456 },
	{ 194560, 195101 },
	{ 196608, 201546 },
	{ 917505, 917505 },
	{ 917536, 917631 },
	{ 917760, 917999 },
	{ 983040, 1048573 },
	{ 1048576, 1114109 },
@end iftangle
	{ -1, -1 },	// end markers
};
static set_item alpha[] = {
	{ 65, 90 },
@ifweave
	...
@end ifweave
@iftangle
	{ 97, 122 },
	{ 170, 170 },
	{ 181, 181 },
	{ 186, 186 },
	{ 192, 214 },
	{ 216, 246 },
	{ 248, 705 },
	{ 710, 721 },
	{ 736, 740 },
	{ 748, 748 },
	{ 750, 750 },
	{ 837, 837 },
	{ 880, 884 },
	{ 886, 887 },
	{ 890, 893 },
	{ 895, 895 },
	{ 902, 902 },
	{ 904, 906 },
	{ 908, 908 },
	{ 910, 929 },
	{ 931, 1013 },
	{ 1015, 1153 },
	{ 1162, 1327 },
	{ 1329, 1366 },
	{ 1369, 1369 },
	{ 1376, 1416 },
	{ 1456, 1469 },
	{ 1471, 1471 },
	{ 1473, 1474 },
	{ 1476, 1477 },
	{ 1479, 1479 },
	{ 1488, 1514 },
	{ 1519, 1522 },
	{ 1552, 1562 },
	{ 1568, 1623 },
	{ 1625, 1641 },
	{ 1646, 1747 },
	{ 1749, 1756 },
	{ 1761, 1768 },
	{ 1773, 1788 },
	{ 1791, 1791 },
	{ 1808, 1855 },
	{ 1869, 1969 },
	{ 1984, 2026 },
	{ 2036, 2037 },
	{ 2042, 2042 },
	{ 2048, 2071 },
	{ 2074, 2092 },
	{ 2112, 2136 },
	{ 2144, 2154 },
	{ 2160, 2183 },
	{ 2185, 2190 },
	{ 2208, 2249 },
	{ 2260, 2271 },
	{ 2275, 2281 },
	{ 2288, 2363 },
	{ 2365, 2380 },
	{ 2382, 2384 },
	{ 2389, 2403 },
	{ 2406, 2415 },
	{ 2417, 2435 },
	{ 2437, 2444 },
	{ 2447, 2448 },
	{ 2451, 2472 },
	{ 2474, 2480 },
	{ 2482, 2482 },
	{ 2486, 2489 },
	{ 2493, 2500 },
	{ 2503, 2504 },
	{ 2507, 2508 },
	{ 2510, 2510 },
	{ 2519, 2519 },
	{ 2524, 2525 },
	{ 2527, 2531 },
	{ 2534, 2545 },
	{ 2556, 2556 },
	{ 2561, 2563 },
	{ 2565, 2570 },
	{ 2575, 2576 },
	{ 2579, 2600 },
	{ 2602, 2608 },
	{ 2610, 2611 },
	{ 2613, 2614 },
	{ 2616, 2617 },
	{ 2622, 2626 },
	{ 2631, 2632 },
	{ 2635, 2636 },
	{ 2641, 2641 },
	{ 2649, 2652 },
	{ 2654, 2654 },
	{ 2662, 2677 },
	{ 2689, 2691 },
	{ 2693, 2701 },
	{ 2703, 2705 },
	{ 2707, 2728 },
	{ 2730, 2736 },
	{ 2738, 2739 },
	{ 2741, 2745 },
	{ 2749, 2757 },
	{ 2759, 2761 },
	{ 2763, 2764 },
	{ 2768, 2768 },
	{ 2784, 2787 },
	{ 2790, 2799 },
	{ 2809, 2812 },
	{ 2817, 2819 },
	{ 2821, 2828 },
	{ 2831, 2832 },
	{ 2835, 2856 },
	{ 2858, 2864 },
	{ 2866, 2867 },
	{ 2869, 2873 },
	{ 2877, 2884 },
	{ 2887, 2888 },
	{ 2891, 2892 },
	{ 2902, 2903 },
	{ 2908, 2909 },
	{ 2911, 2915 },
	{ 2918, 2927 },
	{ 2929, 2929 },
	{ 2946, 2947 },
	{ 2949, 2954 },
	{ 2958, 2960 },
	{ 2962, 2965 },
	{ 2969, 2970 },
	{ 2972, 2972 },
	{ 2974, 2975 },
	{ 2979, 2980 },
	{ 2984, 2986 },
	{ 2990, 3001 },
	{ 3006, 3010 },
	{ 3014, 3016 },
	{ 3018, 3020 },
	{ 3024, 3024 },
	{ 3031, 3031 },
	{ 3046, 3055 },
	{ 3072, 3075 },
	{ 3077, 3084 },
	{ 3086, 3088 },
	{ 3090, 3112 },
	{ 3114, 3129 },
	{ 3133, 3140 },
	{ 3142, 3144 },
	{ 3146, 3148 },
	{ 3157, 3158 },
	{ 3160, 3162 },
	{ 3165, 3165 },
	{ 3168, 3171 },
	{ 3174, 3183 },
	{ 3200, 3203 },
	{ 3205, 3212 },
	{ 3214, 3216 },
	{ 3218, 3240 },
	{ 3242, 3251 },
	{ 3253, 3257 },
	{ 3261, 3268 },
	{ 3270, 3272 },
	{ 3274, 3276 },
	{ 3285, 3286 },
	{ 3293, 3294 },
	{ 3296, 3299 },
	{ 3302, 3311 },
	{ 3313, 3314 },
	{ 3328, 3340 },
	{ 3342, 3344 },
	{ 3346, 3386 },
	{ 3389, 3396 },
	{ 3398, 3400 },
	{ 3402, 3404 },
	{ 3406, 3406 },
	{ 3412, 3415 },
	{ 3423, 3427 },
	{ 3430, 3439 },
	{ 3450, 3455 },
	{ 3457, 3459 },
	{ 3461, 3478 },
	{ 3482, 3505 },
	{ 3507, 3515 },
	{ 3517, 3517 },
	{ 3520, 3526 },
	{ 3535, 3540 },
	{ 3542, 3542 },
	{ 3544, 3551 },
	{ 3558, 3567 },
	{ 3570, 3571 },
	{ 3585, 3642 },
	{ 3648, 3654 },
	{ 3661, 3661 },
	{ 3664, 3673 },
	{ 3713, 3714 },
	{ 3716, 3716 },
	{ 3718, 3722 },
	{ 3724, 3747 },
	{ 3749, 3749 },
	{ 3751, 3769 },
	{ 3771, 3773 },
	{ 3776, 3780 },
	{ 3782, 3782 },
	{ 3789, 3789 },
	{ 3792, 3801 },
	{ 3804, 3807 },
	{ 3840, 3840 },
	{ 3872, 3881 },
	{ 3904, 3911 },
	{ 3913, 3948 },
	{ 3953, 3969 },
	{ 3976, 3991 },
	{ 3993, 4028 },
	{ 4096, 4150 },
	{ 4152, 4152 },
	{ 4155, 4169 },
	{ 4176, 4253 },
	{ 4256, 4293 },
	{ 4295, 4295 },
	{ 4301, 4301 },
	{ 4304, 4346 },
	{ 4348, 4680 },
	{ 4682, 4685 },
	{ 4688, 4694 },
	{ 4696, 4696 },
	{ 4698, 4701 },
	{ 4704, 4744 },
	{ 4746, 4749 },
	{ 4752, 4784 },
	{ 4786, 4789 },
	{ 4792, 4798 },
	{ 4800, 4800 },
	{ 4802, 4805 },
	{ 4808, 4822 },
	{ 4824, 4880 },
	{ 4882, 4885 },
	{ 4888, 4954 },
	{ 4992, 5007 },
	{ 5024, 5109 },
	{ 5112, 5117 },
	{ 5121, 5740 },
	{ 5743, 5759 },
	{ 5761, 5786 },
	{ 5792, 5866 },
	{ 5870, 5880 },
	{ 5888, 5907 },
	{ 5919, 5939 },
	{ 5952, 5971 },
	{ 5984, 5996 },
	{ 5998, 6000 },
	{ 6002, 6003 },
	{ 6016, 6067 },
	{ 6070, 6088 },
	{ 6103, 6103 },
	{ 6108, 6108 },
	{ 6112, 6121 },
	{ 6160, 6169 },
	{ 6176, 6264 },
	{ 6272, 6314 },
	{ 6320, 6389 },
	{ 6400, 6430 },
	{ 6432, 6443 },
	{ 6448, 6456 },
	{ 6470, 6509 },
	{ 6512, 6516 },
	{ 6528, 6571 },
	{ 6576, 6601 },
	{ 6608, 6617 },
	{ 6656, 6683 },
	{ 6688, 6750 },
	{ 6753, 6772 },
	{ 6784, 6793 },
	{ 6800, 6809 },
	{ 6823, 6823 },
	{ 6847, 6848 },
	{ 6860, 6862 },
	{ 6912, 6963 },
	{ 6965, 6979 },
	{ 6981, 6988 },
	{ 6992, 7001 },
	{ 7040, 7081 },
	{ 7084, 7141 },
	{ 7143, 7153 },
	{ 7168, 7222 },
	{ 7232, 7241 },
	{ 7245, 7293 },
	{ 7296, 7304 },
	{ 7312, 7354 },
	{ 7357, 7359 },
	{ 7401, 7404 },
	{ 7406, 7411 },
	{ 7413, 7414 },
	{ 7418, 7418 },
	{ 7424, 7615 },
	{ 7655, 7668 },
	{ 7680, 7957 },
	{ 7960, 7965 },
	{ 7968, 8005 },
	{ 8008, 8013 },
	{ 8016, 8023 },
	{ 8025, 8025 },
	{ 8027, 8027 },
	{ 8029, 8029 },
	{ 8031, 8061 },
	{ 8064, 8116 },
	{ 8118, 8124 },
	{ 8126, 8126 },
	{ 8130, 8132 },
	{ 8134, 8140 },
	{ 8144, 8147 },
	{ 8150, 8155 },
	{ 8160, 8172 },
	{ 8178, 8180 },
	{ 8182, 8188 },
	{ 8305, 8305 },
	{ 8319, 8319 },
	{ 8336, 8348 },
	{ 8450, 8450 },
	{ 8455, 8455 },
	{ 8458, 8467 },
	{ 8469, 8469 },
	{ 8473, 8477 },
	{ 8484, 8484 },
	{ 8486, 8486 },
	{ 8488, 8488 },
	{ 8490, 8493 },
	{ 8495, 8505 },
	{ 8508, 8511 },
	{ 8517, 8521 },
	{ 8526, 8526 },
	{ 8544, 8584 },
	{ 9398, 9449 },
	{ 11264, 11492 },
	{ 11499, 11502 },
	{ 11506, 11507 },
	{ 11520, 11557 },
	{ 11559, 11559 },
	{ 11565, 11565 },
	{ 11568, 11623 },
	{ 11631, 11631 },
	{ 11648, 11670 },
	{ 11680, 11686 },
	{ 11688, 11694 },
	{ 11696, 11702 },
	{ 11704, 11710 },
	{ 11712, 11718 },
	{ 11720, 11726 },
	{ 11728, 11734 },
	{ 11736, 11742 },
	{ 11744, 11775 },
	{ 11823, 11823 },
	{ 12293, 12295 },
	{ 12321, 12329 },
	{ 12337, 12341 },
	{ 12344, 12348 },
	{ 12353, 12438 },
	{ 12445, 12447 },
	{ 12449, 12538 },
	{ 12540, 12543 },
	{ 12549, 12591 },
	{ 12593, 12686 },
	{ 12704, 12735 },
	{ 12784, 12799 },
	{ 13312, 19903 },
	{ 19968, 42124 },
	{ 42192, 42237 },
	{ 42240, 42508 },
	{ 42512, 42539 },
	{ 42560, 42606 },
	{ 42612, 42619 },
	{ 42623, 42735 },
	{ 42775, 42783 },
	{ 42786, 42888 },
	{ 42891, 42954 },
	{ 42960, 42961 },
	{ 42963, 42963 },
	{ 42965, 42969 },
	{ 42994, 43013 },
	{ 43015, 43047 },
	{ 43072, 43123 },
	{ 43136, 43203 },
	{ 43205, 43205 },
	{ 43216, 43225 },
	{ 43250, 43255 },
	{ 43259, 43259 },
	{ 43261, 43306 },
	{ 43312, 43346 },
	{ 43360, 43388 },
	{ 43392, 43442 },
	{ 43444, 43455 },
	{ 43471, 43481 },
	{ 43488, 43518 },
	{ 43520, 43574 },
	{ 43584, 43597 },
	{ 43600, 43609 },
	{ 43616, 43638 },
	{ 43642, 43710 },
	{ 43712, 43712 },
	{ 43714, 43714 },
	{ 43739, 43741 },
	{ 43744, 43759 },
	{ 43762, 43765 },
	{ 43777, 43782 },
	{ 43785, 43790 },
	{ 43793, 43798 },
	{ 43808, 43814 },
	{ 43816, 43822 },
	{ 43824, 43866 },
	{ 43868, 43881 },
	{ 43888, 44010 },
	{ 44016, 44025 },
	{ 44032, 55203 },
	{ 55216, 55238 },
	{ 55243, 55291 },
	{ 63744, 64109 },
	{ 64112, 64217 },
	{ 64256, 64262 },
	{ 64275, 64279 },
	{ 64285, 64296 },
	{ 64298, 64310 },
	{ 64312, 64316 },
	{ 64318, 64318 },
	{ 64320, 64321 },
	{ 64323, 64324 },
	{ 64326, 64433 },
	{ 64467, 64829 },
	{ 64848, 64911 },
	{ 64914, 64967 },
	{ 65008, 65019 },
	{ 65136, 65140 },
	{ 65142, 65276 },
	{ 65296, 65305 },
	{ 65313, 65338 },
	{ 65345, 65370 },
	{ 65382, 65470 },
	{ 65474, 65479 },
	{ 65482, 65487 },
	{ 65490, 65495 },
	{ 65498, 65500 },
	{ 65536, 65547 },
	{ 65549, 65574 },
	{ 65576, 65594 },
	{ 65596, 65597 },
	{ 65599, 65613 },
	{ 65616, 65629 },
	{ 65664, 65786 },
	{ 65856, 65908 },
	{ 66176, 66204 },
	{ 66208, 66256 },
	{ 66304, 66335 },
	{ 66349, 66378 },
	{ 66384, 66426 },
	{ 66432, 66461 },
	{ 66464, 66499 },
	{ 66504, 66511 },
	{ 66513, 66517 },
	{ 66560, 66717 },
	{ 66720, 66729 },
	{ 66736, 66771 },
	{ 66776, 66811 },
	{ 66816, 66855 },
	{ 66864, 66915 },
	{ 66928, 66938 },
	{ 66940, 66954 },
	{ 66956, 66962 },
	{ 66964, 66965 },
	{ 66967, 66977 },
	{ 66979, 66993 },
	{ 66995, 67001 },
	{ 67003, 67004 },
	{ 67072, 67382 },
	{ 67392, 67413 },
	{ 67424, 67431 },
	{ 67456, 67461 },
	{ 67463, 67504 },
	{ 67506, 67514 },
	{ 67584, 67589 },
	{ 67592, 67592 },
	{ 67594, 67637 },
	{ 67639, 67640 },
	{ 67644, 67644 },
	{ 67647, 67669 },
	{ 67680, 67702 },
	{ 67712, 67742 },
	{ 67808, 67826 },
	{ 67828, 67829 },
	{ 67840, 67861 },
	{ 67872, 67897 },
	{ 67968, 68023 },
	{ 68030, 68031 },
	{ 68096, 68099 },
	{ 68101, 68102 },
	{ 68108, 68115 },
	{ 68117, 68119 },
	{ 68121, 68149 },
	{ 68192, 68220 },
	{ 68224, 68252 },
	{ 68288, 68295 },
	{ 68297, 68324 },
	{ 68352, 68405 },
	{ 68416, 68437 },
	{ 68448, 68466 },
	{ 68480, 68497 },
	{ 68608, 68680 },
	{ 68736, 68786 },
	{ 68800, 68850 },
	{ 68864, 68903 },
	{ 68912, 68921 },
	{ 69248, 69289 },
	{ 69291, 69292 },
	{ 69296, 69297 },
	{ 69376, 69404 },
	{ 69415, 69415 },
	{ 69424, 69445 },
	{ 69488, 69505 },
	{ 69552, 69572 },
	{ 69600, 69622 },
	{ 69632, 69701 },
	{ 69734, 69743 },
	{ 69745, 69749 },
	{ 69762, 69816 },
	{ 69826, 69826 },
	{ 69840, 69864 },
	{ 69872, 69881 },
	{ 69888, 69938 },
	{ 69942, 69951 },
	{ 69956, 69959 },
	{ 69968, 70002 },
	{ 70006, 70006 },
	{ 70016, 70079 },
	{ 70081, 70084 },
	{ 70094, 70106 },
	{ 70108, 70108 },
	{ 70144, 70161 },
	{ 70163, 70196 },
	{ 70199, 70199 },
	{ 70206, 70206 },
	{ 70272, 70278 },
	{ 70280, 70280 },
	{ 70282, 70285 },
	{ 70287, 70301 },
	{ 70303, 70312 },
	{ 70320, 70376 },
	{ 70384, 70393 },
	{ 70400, 70403 },
	{ 70405, 70412 },
	{ 70415, 70416 },
	{ 70419, 70440 },
	{ 70442, 70448 },
	{ 70450, 70451 },
	{ 70453, 70457 },
	{ 70461, 70468 },
	{ 70471, 70472 },
	{ 70475, 70476 },
	{ 70480, 70480 },
	{ 70487, 70487 },
	{ 70493, 70499 },
	{ 70656, 70721 },
	{ 70723, 70725 },
	{ 70727, 70730 },
	{ 70736, 70745 },
	{ 70751, 70753 },
	{ 70784, 70849 },
	{ 70852, 70853 },
	{ 70855, 70855 },
	{ 70864, 70873 },
	{ 71040, 71093 },
	{ 71096, 71102 },
	{ 71128, 71133 },
	{ 71168, 71230 },
	{ 71232, 71232 },
	{ 71236, 71236 },
	{ 71248, 71257 },
	{ 71296, 71349 },
	{ 71352, 71352 },
	{ 71360, 71369 },
	{ 71424, 71450 },
	{ 71453, 71466 },
	{ 71472, 71481 },
	{ 71488, 71494 },
	{ 71680, 71736 },
	{ 71840, 71913 },
	{ 71935, 71942 },
	{ 71945, 71945 },
	{ 71948, 71955 },
	{ 71957, 71958 },
	{ 71960, 71989 },
	{ 71991, 71992 },
	{ 71995, 71996 },
	{ 71999, 72002 },
	{ 72016, 72025 },
	{ 72096, 72103 },
	{ 72106, 72151 },
	{ 72154, 72159 },
	{ 72161, 72161 },
	{ 72163, 72164 },
	{ 72192, 72242 },
	{ 72245, 72254 },
	{ 72272, 72343 },
	{ 72349, 72349 },
	{ 72368, 72440 },
	{ 72704, 72712 },
	{ 72714, 72758 },
	{ 72760, 72766 },
	{ 72768, 72768 },
	{ 72784, 72793 },
	{ 72818, 72847 },
	{ 72850, 72871 },
	{ 72873, 72886 },
	{ 72960, 72966 },
	{ 72968, 72969 },
	{ 72971, 73014 },
	{ 73018, 73018 },
	{ 73020, 73021 },
	{ 73023, 73025 },
	{ 73027, 73027 },
	{ 73030, 73031 },
	{ 73040, 73049 },
	{ 73056, 73061 },
	{ 73063, 73064 },
	{ 73066, 73102 },
	{ 73104, 73105 },
	{ 73107, 73110 },
	{ 73112, 73112 },
	{ 73120, 73129 },
	{ 73440, 73462 },
	{ 73648, 73648 },
	{ 73728, 74649 },
	{ 74752, 74862 },
	{ 74880, 75075 },
	{ 77712, 77808 },
	{ 77824, 78894 },
	{ 82944, 83526 },
	{ 92160, 92728 },
	{ 92736, 92766 },
	{ 92768, 92777 },
	{ 92784, 92862 },
	{ 92864, 92873 },
	{ 92880, 92909 },
	{ 92928, 92975 },
	{ 92992, 92995 },
	{ 93008, 93017 },
	{ 93027, 93047 },
	{ 93053, 93071 },
	{ 93760, 93823 },
	{ 93952, 94026 },
	{ 94031, 94087 },
	{ 94095, 94111 },
	{ 94176, 94177 },
	{ 94179, 94179 },
	{ 94192, 94193 },
	{ 94208, 100343 },
	{ 100352, 101589 },
	{ 101632, 101640 },
	{ 110576, 110579 },
	{ 110581, 110587 },
	{ 110589, 110590 },
	{ 110592, 110882 },
	{ 110928, 110930 },
	{ 110948, 110951 },
	{ 110960, 111355 },
	{ 113664, 113770 },
	{ 113776, 113788 },
	{ 113792, 113800 },
	{ 113808, 113817 },
	{ 113822, 113822 },
	{ 119808, 119892 },
	{ 119894, 119964 },
	{ 119966, 119967 },
	{ 119970, 119970 },
	{ 119973, 119974 },
	{ 119977, 119980 },
	{ 119982, 119993 },
	{ 119995, 119995 },
	{ 119997, 120003 },
	{ 120005, 120069 },
	{ 120071, 120074 },
	{ 120077, 120084 },
	{ 120086, 120092 },
	{ 120094, 120121 },
	{ 120123, 120126 },
	{ 120128, 120132 },
	{ 120134, 120134 },
	{ 120138, 120144 },
	{ 120146, 120485 },
	{ 120488, 120512 },
	{ 120514, 120538 },
	{ 120540, 120570 },
	{ 120572, 120596 },
	{ 120598, 120628 },
	{ 120630, 120654 },
	{ 120656, 120686 },
	{ 120688, 120712 },
	{ 120714, 120744 },
	{ 120746, 120770 },
	{ 120772, 120779 },
	{ 120782, 120831 },
	{ 122624, 122654 },
	{ 122880, 122886 },
	{ 122888, 122904 },
	{ 122907, 122913 },
	{ 122915, 122916 },
	{ 122918, 122922 },
	{ 123136, 123180 },
	{ 123191, 123197 },
	{ 123200, 123209 },
	{ 123214, 123214 },
	{ 123536, 123565 },
	{ 123584, 123627 },
	{ 123632, 123641 },
	{ 124896, 124902 },
	{ 124904, 124907 },
	{ 124909, 124910 },
	{ 124912, 124926 },
	{ 124928, 125124 },
	{ 125184, 125251 },
	{ 125255, 125255 },
	{ 125259, 125259 },
	{ 125264, 125273 },
	{ 126464, 126467 },
	{ 126469, 126495 },
	{ 126497, 126498 },
	{ 126500, 126500 },
	{ 126503, 126503 },
	{ 126505, 126514 },
	{ 126516, 126519 },
	{ 126521, 126521 },
	{ 126523, 126523 },
	{ 126530, 126530 },
	{ 126535, 126535 },
	{ 126537, 126537 },
	{ 126539, 126539 },
	{ 126541, 126543 },
	{ 126545, 126546 },
	{ 126548, 126548 },
	{ 126551, 126551 },
	{ 126553, 126553 },
	{ 126555, 126555 },
	{ 126557, 126557 },
	{ 126559, 126559 },
	{ 126561, 126562 },
	{ 126564, 126564 },
	{ 126567, 126570 },
	{ 126572, 126578 },
	{ 126580, 126583 },
	{ 126585, 126588 },
	{ 126590, 126590 },
	{ 126592, 126601 },
	{ 126603, 126619 },
	{ 126625, 126627 },
	{ 126629, 126633 },
	{ 126635, 126651 },
	{ 127280, 127305 },
	{ 127312, 127337 },
	{ 127344, 127369 },
	{ 130032, 130041 },
	{ 131072, 173791 },
	{ 173824, 177976 },
	{ 177984, 178205 },
	{ 178208, 183969 },
	{ 183984, 191456 },
	{ 194560, 195101 },
	{ 196608, 201546 },
@end iftangle
	{ -1, -1 },	// end markers
};
@

@node Accessing Range Data
@subsection Making Range Data Accessable

We will need an easy way to access the range data
for Unicode, test an eight-bit value, and find out if
a wide character value matches a particular class for non-Unicode
wide character sets.  Thus we need an array of
structures, as follows:

@<static data@>=
static struct _class_data {
	const char *name;				// e.g., "alpha"
	int (*charcheckfunc)(int c);	// function pointer, e.g., isalpha
	wctype_t	wctype;				// from wctype("alpha")
	set_item	*data[2];			// alpha, NULL
} class_data[] = {
	{ "alnum",	isalnum,	0,	{ alpha, digit } },
	{ "alpha",	isalpha,	0,	{ alpha, NULL } },
	{ "blank",	isblank,	0,	{ blank, NULL } },
	{ "cntrl",	iscntrl,	0,	{ cntrl, NULL } },
	{ "digit",	isdigit,	0,	{ digit, NULL } },
	{ "graph",	isgraph,	0,	{ print_graph_common, graph_additional } },
	{ "lower",	islower,	0,	{ lower, NULL } },
	{ "print",	isprint,	0,	{ print_graph_common, print_additional } },
	{ "punct",	ispunct,	0,	{ punct, NULL } },
	{ "space",	isspace,	0,	{ space, NULL } },
	{ "upper",	isupper,	0,	{ upper, NULL } },
	{ "xdigit",	isxdigit,	0,	{ xdigit, NULL } },
	{ NULL, NULL, 0, { NULL, NULL } },
};
@

Given this data structure, we can now start to sketch out
the algorithm for adding ranges of characters that
match a given character class.

@node Inserting Ranges
@subsection Adding Ranges To The charset

We expect the regexp parser to pull the name out of the expression
(e.g., @code{alpha}), and hand that to us as a regular C string.

@<API functions@>=
/* charset_add_cclass --- add a character class, like "alnum" */

int
charset_add_cclass(charset_t *set, const char *cclass)
{
	@<check for NULL pointer@>
	@<check if finalized@>

	int index = find_class(cclass);

	if (index == -1) {
		if (set->mb_cur_max == 1)
			return CSET_ECTYPE;
		else {
			// maybe it's locale-specific
			@<handle non-standard locale-specific character class@>
		}
	}

	// we have a standard cclass
	if (set->mb_cur_max == 1) {
		@<loop over 256 values for given class@>
	} else if (set->is_utf8) {
		@<add predefined ranges@>
	} else {
		@<handle locale-specific standard character class@>
	}

	return CSET_SUCCESS;
}
@

@<loop over 256 values for given class@>=
int (*charcheckfunc)(int c) = class_data[index].charcheckfunc;
for (int32_t i = 0; i < 256; i++) {
	if (charcheckfunc(i)) {
		int ret = charset_add_char(set, i);
		if (ret != CSET_SUCCESS)
			return ret;
	}
}
@

@<add predefined ranges@>=
set_item *data[2];

data[0] = class_data[index].data[0];
data[1] = class_data[index].data[1];

for (int i = 0; i < 2; i++) {
	if (data[i] == NULL)
		break;
	for (j = 0; data[i][j].start != -1; j++) {
		int ret = charset_add_range(set, data[i][j].start, data[i][j].end);
		if (ret != CSET_SUCCESS)
			return ret;
	}
}
@

@<handle non-standard locale-specific character class@>=
wctype_t ctype = wctype(cclass);	// look it up
if (ctype == 0)	// it's invalid
	return CSET_ECTYPE;

// this saves the locale + cclass info for possible reuse
return wide_char_range_loop(set, cclass, ctype);
@

@<handle locale-specific standard character class@>=
wctype_t ctype = class_data[index].ctype;
if (ctype == 0) {	// haven't checked it yet
	ctype = wctype(cclass);

	if (ctype == 0)	// bad class, should not happen for standard classes
		return CSET_ECTYPE;
}

// all ok..
class_data[index].ctype = ctype;	// save for next time
// this saves the locale + cclass info for possible reuse
return wide_char_range_loop(set, cclass, ctype);
@

As with the regular character and the ranges, duplicates are
possible; that's cleaned up upon finalization.

@<API declarations@>=
int charset_add_cclass(charset_t *set, const char *cclass);
@

@node Finding A Class
@subsection Finding The Class

Because we don't expect to have to do this a lot, we use a
simple linear search:

@<helper functions@>=
/* find_cclass --- search class data for a known character class */

static int
find_class(const char *cclass)
{
	int i;

	for (i = 0; class_data[i].name != NULL; i++)
		if (strcmp(class_data[i].name, cclass) == 0)
			return i;

	return -1;
}
@

@node Wide Char Loop
@subsection Looping Over All Possible Values

If we get here, we're in a wide character locale that isn't Unicode.
So we have to ask the C library to tell us which values match
the particular character class.

@subsubection Avoiding Recomputing Things

We want to avoid doing this more than once for any given combination
of a locale and character class. To that end, we ``memoize'', building
a charset and saving it for possible reuse.

Let's talk about how to cache the data. It'd be nice to avoid doing our
hash table, and @i{hsearch}(3), while standard, is kinda yucky.  Instead,
we'll try to take advantage of the fact that locale names all start with
one of the 52 letters in the English alphabet. We'll thus have an array
of 53 elements, one for each letter and an extra one just in case somebody
is cute and starts a locale name with some other character.

@<static data@>=
static struct _class_cache {
	const char *name;
	charset *set;
	struct _class_cache *next;	// linked list
} *class_cache[53];
@


@<helper functions@>=
/* find_class_in_cache --- lookup and/or create locale + class in the table */

static charset *
find_class_in_cache(const char *cclass, int *errcode)
{
	assert(cclass != NULL && errcode != NULL);

	const char *locale = setlocale(LC_CTYPE, NULL);	// query locale
	char *buf = malloc(strlen(locale) + 1 + strlen(cclass) + 1);
	if (buf == NULL) {
		*errcode = CSET_ESPACE;
		return NULL;
	}

	sprintf(buf, "%s+%s", locale, cclass);

	int index;
	static char letters[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	char *cp = strchr(letters, buf[0]);

	if (cp == NULL)
		index = 52;
	else
		index = cp - letters;

	struct _class_cache *pcache = class_cache[index];
	if (pcache == NULL) {
		@<allocate a new cache entry, fill it in@>
		class_cache[index] = pcache;
		// fall through to return
	} else {
		for (; pcache != NULL; pcache = pcache->next) {
			if (strcmp(pcache->name, buf) == 0) {	// found it
				free(buf);
				goto done;
			}
		}
		@<allocate a new cache entry, fill it in@>
		pcache->next = class_cache[index];	// push onto front of the chain
		class_cache[index] = pcache;
		// fall through to return
	}

done:
	*errcode = CSET_SUCCESS;
	return pache->set;
}
@

@<allocate a new cache entry, fill it in@>=
pcache = malloc(sizeof(struct _class_cache));
if (pcache == NULL) {
	*errcode = CSET_ESPACE;
	return NULL;
}
pcache->name = buf;
pcache->next = NULL;
charset_t *newset = charset_create(errcode, set->mb_cur_max, set->is_utf8);
if (newset == NULL) {
	*errcode = CSET_ESPACE;
	free(pcache->name);
	return NULL;
}
pcache->set = newset;
@


@<helper functions@>=
/* wide_char_range_loop --- loop over all possible characters to match a ctype, and cache it */

static int
wide_char_range_loop(charset_t *set, const char *cclass, wctype_t ctype)
{
}
@

@node Copying A charset
@section Copying A @code{charset_t}

Copying a charset is straightforward, involving memory allocation
and copying all the bits over appropriately.

@<API functions@>=
/* charset_copy --- create a new charset that is copy of the original */

charset_t *
charset_copy(charset_t *set, int *errcode)
{
	if (errcode == NULL)
		return NULL;

	@<check for NULL pointer@>
	charset_t *newset = charset_create(errcode, set->mb_cur_max, set->is_utf8);
	if (newset == NULL)
		return NULL;

	memcpy(newset, set, sizeof(*set));
	newset->chars = malloc(newset->nchars_allocated * sizeof(int32_t));
	if (newset->chars == NULL) {
		*errcode = CSET_ESPACE;
		free(newset);
		return NULL;
	} else
		memcpy(newset->chars, set->chars, newset->nchars_allocated * sizeof(int32_t));

	newset->items = malloc(newset->allocated * sizeof(set_item));
	if (newset->items == NULL) {
		*errcode = CSET_ESPACE;
		free(newset->chars);
		free(newset);
		return NULL;
	} else
		memcpy(newset->items, set->items, newset->allocated * sizeof(set_item));

	*errcode = CSET_SUCCESS;
	return newset;
}
@

@<API declarations@>=
charset_t *charset_copy(charset_t *set, int *errcode);
@

@node Merging charsets
@section Merging One @code{charset_t} Into Another

Mergin

@<API functions@>=
int
charset_merge(charset *set /*dest*/, charset *src)
{
	@<check for NULL pointer@>
	if (src == NULL)
		return CSET_EBADPTR;
	@<check if finalized@>

	int new_char_count = set->nchars_inuse + src->nchars_inuse + 1;
	int new_item_count = set->nelems + src->nelems;

	int32_t *new_chars = malloc(new_char_count * sizeof(int32_t));
	if (new_chars == NULL)
		return CSET_ESPACE;

	set_item *new_items = malloc(new_item_count * sizeof(set_item));
	if (new_items == NULL) {
		free(new_chars);
		return CSET_ESPACE;
	}

	// allocated the space ok, now copy all the stuff in
	memcpy(new_chars, set->chars, set->nchars_inuse * sizeof(int32_t));
	memcpy(new_chars + set->nchars_inuse, src->chars, src->nchars_inuse * sizeof(int32_t));
	new_chars[new_char_count-1] = L'\0';

	memcpy(new_items, set->items, set->nelems * sizeof(set_item));
	memcpy(new_items + set->nelems, src->items, src->nelems * sizeof(set_item));

	// now update dest
	free(set->chars);
	set->chars = new_chars;
	set->nchars_inuse = new_char_count - 1;
	set->nchars_allocated = new_char_count;

	free(set->items);
	set->items = new_items;
	set->nelems = set->allocated = new_item_count;

	return CSET_SUCCESS;
}
@

@<API declarations@>=
int charset_merge(charset *dest, charset *src);
@

@node Using the charset_t
@chapter Using The @code{charset_t} Once It's Built

A fundamental assumption is that the array of items
is sorted and uniqued.
We see later how this is made to happen.

The following function tests if a character is contained
in the @code{charset_t}.

@<API functions@>=
/* charset_in_set --- see if a character is in the set */

bool
charset_in_set(const charset_t *set, int32_t the_char)
{
	if (set == NULL || the_char < 0)
		return false;

	if (! set->finalized) {
		charset_finalize((charset_t *) set);

		if (! set->finalized)	// finalize() failed
			return false;
	}

	if (the_char == L'\n' && set->no_newlines)	// FIXME: is this still right?
		return false;

	bool found = is_found(set, the_char);

	return found;
}
@

When we're done with the @code{charset_t}, we should
release all the storage it uses.

@<API functions@>=
/* charset_free --- free all storage */

int
charset_free(const charset_t *set)
{
	@<check for NULL pointer@>
	// no need to check for finalized

	if (set->items != NULL)
		free((void *) set->items);

	if (set->chars != NULL)
		free((void *) set->chars);

	free((void *) set);

	return CSET_SUCCESS;
}
@

@<API declarations@>=
bool charset_in_set(const charset_t *set, int32_t the_char);
int charset_free(const charset_t *set);
@

@node Searching
@section Searching For A Character

The actual searching is separate from the ``is complemented'' test to
keep things simple.

@<helper functions@>=
@<item comparison functions@>

/* is_found --- return true if the character is found */

static bool
is_found(const charset_t *set, int32_t the_char)
{
	set_item *items = set->items;
	int i;

	@<Check for empty set@>
	@<Special case search for only one item in the set@>
	@<Search in the ranges@>
}
@

MinRX wants to use a cute trick for matching all characters (dot).
It creates a brand new set and then inverts it.  So, a set
that's totally empty has to work; this means we can't assume
that @code{set->items} has something in it.

@<Check for empty set@>=
if (set->items == NULL)		// empty set, can't match
	return false;
@

Searching for a matching @code{set_item} is
done using binary search:

@<Search in the ranges@>=
// binary search to see if we have it
set_item *found;
set_item key;
key.item_type = RANGE_ITEM;
key.start = key.end = the_char;

found = bsearch(& key, set->items, set->nelems,
				sizeof(set_item), item_compare_for_searching);

return found != NULL;
@

As a special case, if the set has only one character
in it, we avoid the overhead of binary search:

@<Special case search for only one item in the set@>=
if (set->nelems == 1)
    return (set->items[0].start <= the_char && the_char <= set->items[0].end);
@

We need two comparison functions: one for use by @code{bsearch()} and
a different one for use by by @code{qsort()} (which we'll see later).
The comparisons are fundamentally different. When sorting,
we're comparing array elements against each other. When
searching, we compare elements one at a time against a key.

Here is the searching function.  POSIX tells us that the first
argument is the key and the second is the array element being
compared.

@<item comparison functions@>=
/* item_compare_for_searching --- compare two set_items */

static int
item_compare_for_searching(const void *k, const void *e)
{
	set_item *thekey = (set_item *) k;
	set_item *elem = (set_item *) e;

	if (elem->start <= thekey->start && thekey->start <= elem->end)
		return 0;	// found it
	else if (thekey->end < elem->start)
		return -1;
	else {
		assert(thekey->start > elem->end);
		return 1;
	}
}
@

We need the header file for assertions:

@<includes@>=
#include <assert.h>
@

@node Printing
@section Printing The Data Structure

Printing the data is straightforward.
Initially, this routine was for debugging.
It turns out that it will be helpful to build up a
charset and then dump it out ranges for use in other
C code.
@xref{Generating Ranges}, for the rationale for
this feature.

@<API functions@>=
/* charset_dump --- dump out the data structures */

void
charset_dump(const charset_t *set, FILE *fp, bool use_c_format)
{
	static const char *boolval[] = {
		"false",
		"true",
	};

	if (set == NULL || fp == NULL)
		return;

	set_item *items = set->items;
	if (use_c_format) {
		@<dump ranges in C format@>
	} else {
		@<dump in debug format@>
	}
	fflush(fp);
}
@

The debug format prints the structure members in a (more or less)
human readable fashion:

@<dump in debug format@>=
fprintf(fp, "no_newlines = %s\n", boolval[!! set->no_newlines]);
fprintf(fp, "finalized = %s\n", boolval[!! set->finalized]);

for (int i = 0; i < set->nelems; i++) {
	fprintf(fp, "%3d. RANGE: start = L'%lc', end = L'%lc'\n",
		i, items[i].start, items[i].end);
}
@

Dumping the ranges in C format is simpler:

@<dump ranges in C format@>=
for (int i = 0; i < set->nelems; i++) {
	assert(items[i].item_type == RANGE_ITEM);
	fprintf(fp, "\t{ %d, %d },\n", items[i].start, items[i].end);
}
@

@<API declarations@>=
void charset_dump(const charset_t *set, FILE *fp, bool use_c_format);
@

@node Finalizing
@chapter Finalizing The Charset

Now it's time to do the hard part, which is to produce the
final data structure.

@<API declarations@>=
void charset_finalize(charset_t *set);
@

@<helper functions@>=
/* charset_finalize --- condense all the info into the final data structure */

void
charset_finalize(charset_t *set)
{
	assert(set != NULL);
	int result = 0;

	@<sort wide character list@>
	@<condense wide character list into @code{set_item}s@>
	@<condense final array of @code{set_item}s@>
	set->finalized = true;
}
@

Once we have the list of wide characters, sorting it is easy:

@<sort wide character list@>=
qsort(set->chars, set->nchars_inuse, sizeof(int32_t), int32_t_compare);
@

@noindent
The comparison function is trivial:

@<item comparison functions@>=
/* int32_t_compare --- compare two int32_t values for qsort */

static int
int32_t_compare(const void *l, const void *r)
{
	int32_t_t *left = (wint_t *) l;
	int32_t_t *right = (wint_t *) r;

	return *left - *right;
}
@

Now some of the fun begins:

@<condense wide character list into @code{set_item}s@>=
@<remove duplicate wide characters@>
@<generate @code{set_item}s@>
@

Condensing the list simply shifts the characters down
as duplicates are found.  This is painful if there are
maybe thousands of duplicates but for typical regular
expressions, there shouldn't be any problem.

@<remove duplicate wide characters@>=
size_t i, j;
for (i = 0, j = 1; j < set->nchars_inuse; i++, j++) {
	if (set->chars[i] == set->chars[j]) {
		for (int k = j + 1; k < set->nchars_inuse; j++, k++) {
			set->chars[j] = set->chars[k];
		}
		set->chars[j] = L'\0';

		set->nchars_inuse--;
		j = i;
		i--;	// keep searching from same spot
	}
}
if (set->chars != NULL)
	set->chars[set->nchars_inuse] = L'\0';	// not strictly necessary, but doesn't hurt
@

Once we have a sorted and uniqued list of wide characters,
generating the correct ranges is relatively easy.

@<generate @code{set_item}s@>=
size_t range_start, total;
range_start = total = 0;
for (i = 0, j = 1; j < set->nchars_inuse; i++, j++) {
	if (set->chars[j] == set->chars[i] + 1) {	// ab...
		continue;
	} else if (set->chars[j] > set->chars[i] + 1) {
		// acd...
		// push a and start next range at c
		result = charset_add_range(set, set->chars[range_start], set->chars[i]);
		if (result != CSET_SUCCESS)
			return;
		total++;
		range_start = j;
	}
}
// Get any final range or character
if (set->nchars_inuse > 0 && range_start <= set->nchars_inuse - 1) {
	result = charset_add_range(set, set->chars[range_start],
				set->chars[set->nchars_inuse-1]);
	if (result != CSET_SUCCESS)
		return;
	total++;
}
set->nchars_inuse = total;
@

@<condense final array of @code{set_item}s@>=
// sort it
qsort(set->items, set->nelems,
		sizeof(set_item), item_compare_for_sorting);

// condense it
set_item *items = set->items;
for (i = 0, j = 1; j < set->nelems; i++, j++) {
	@<condense overlapping ranges@>
}
@

For sorting, we sort the @code{set_item}s based on their @code{start}
value.  Here's the sorting function:

@<item comparison functions@>=
/* item_compare_for_sorting --- compare two set_items */

static int
item_compare_for_sorting(const void *l, const void *r)
{
	set_item *left = (set_item *) l;
	set_item *right = (set_item *) r;

	return left->start - right->start;
}
@

There are multiple possibilities for
overlapping ranges. For example, there's nothing stopping
someone from writing @code{[a-q12c-h]}, or @code{[bca123a-c]} or
almost anything else.  After sorting the various ranges, we
end up with the following possibilities:

@itemize @bullet
@item
Exact duplicate ranges:

@example
          +---+---+
item[i]   | a | d |        +---+---+
          +---+---+   ==>  | a | d |   item[i]
item[j]   | a | d |        +---+---+
          +---+---+
@end example

@noindent
The duplicate should be removed.

@item
Adjacent ranges.

@example
          +---+---+
item[i]   | a | d |                +---+---+
          +---+---+---+----   ==>  | a | h |   item[i]
item[j]           | e | h |        +---+---+
                  +---+---+
@end example

@noindent
The first range should be expanded to include the
end point of the second, and the second one should
be removed.

@item
Completely overlapping:

@example
          +----------+
item[i]   | abcdefhi |          +---+---+
          +----------+    ===>  | a | i |   item[i]
item[j]   |    def   |          +---+---+
          +----------+
@end example

@noindent
The second one should be removed.

@item
Partially overlapping on the left:

@example
          +----------+
item[i]   | abcdef   |         +---+---+
          +----------+    ===> | a | h |   item[i]
item[i]   |    defgh |         +---+---+
          +----------+
@end example

@noindent
Since ranges are sorted by @code{start}, we won't
have overlapping on the right.
Here too, the end point of the first range
should become that of the second, and
the second should be removed.
@end itemize

The following sequence of statements implements the logic:

@<condense overlapping ranges@>=
bool need_shift = false;
if (items[i].start == items[j].start && items[i].end == items[j].end) {
	need_shift = true;
} else if (items[i].end + 1 == items[j].start) {
	items[i].end = items[j].end;
	need_shift = true;
} else if (items[i].start < items[j].start && items[i].end > items[j].end) {
	need_shift = true;
} else if (   items[i].start <= items[j].start
           && items[i].end > items[j].start
           && items[j].end >= items[i].end) {
	items[i].end = items[j].end;
	need_shift = true;
}
if (need_shift) {
	@<shift @code{items} down by one@>
}
// otherwise, just continue around the loop
@

@<shift @code{items} down by one@>=
for (int k = j + 1; k < set->nelems; j++, k++)
	items[j] = items[k];

set->nelems--;
i--;	// compensate for loop, continue checking at current position
j = i + 1;
@

@node Source Files
@chapter Source Files

@(charset.h@)=
#ifndef CHARSET_H
#define CHARSET_H 1

@<Copyright statement@>

#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _charset charset_t;

@<API declarations@>

#ifdef __cplusplus
}
#endif
#endif /* CHARSET_H */
@

@(charset.c@)=
@<Copyright statement@>

@<includes@>
#include "charset.h"	// for the charset_t typedef

@<macros@>

@<static data@>

@<data structures@>
@<helper functions@>
@<API functions@>
@

To get it out of the way, here is the copyright statement.

@<Copyright statement@>=
/*
 * Copyright (C) 2023, 2024, 2025, Arnold David Robbins.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * “AS IS” AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
@

We include the standard header files that we'll need:

@<includes@>=
#include <stdio.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
// #include <wctype.h>
// #include <wchar.h>
// #include <locale.h>
@

@node test driver
@chapter A Test Program And Driver

We need a test program, and a shell script to drive it:

@node test program
@section The Test Program

The test program builds a set and then compares one or more characters
against the set.  It takes several options:

@table @option
@item -F
Expect failure. Mutually exclusive with @option{-S}.

@item -S
Expect success. Mutually exclusive with @option{-F}.

@item -D
Match ``dot'' (any character).

@item -d
Dump the data structure.

@item -e
Escapes are allowed (like @command{awk}). By default they are not.

@item -i
Ignore case when matching. By default case is significant.

@item -n
Disallow newlines when matching dot or complemented bracket
expressions.

@item -q
Be quiet: don't print out what we're attempting match.
@end table

@(btest.c@)=
/* btest.c --- a test program for the charset_xxx functions */

@<Copyright statement@>

@<main includes@>

static charset_t *parse_bracket_expr(const char *expr, int flags, int *errcode);
static const char *errcode2string(int errcode);
		
enum flags {
	CS_ESCAPES_ALLOWED	= 0x01,
	CS_IGNORE_CASE		= 0x02,
	CS_NO_NEWLINES		= 0x04,
	CS_DOT			= 0x08,
};

static bool
find_ctype_info(const char *cp,
                const char **the_name, int *errcode,
                size_t mb_cur_max, mbstate_t *mbsp);
@<test helper functions@>

/* main --- parse arguments, run the test */

int
main(int argc, char **argv)
{
	int c;
	wint_t wc;
	char *cp;
	bool expect_success = false, expect_failure = false;
	bool dump_data = false, quiet = false;

	@<parse command line arguments@>
	setlocale(LC_ALL, "");
	@<compile the expression@>
	@<test each wide character in the test case against the expression@>
	@<dump the data if needed@>

	return EXIT_SUCCESS;
}
@

@<main includes@>=
@<includes@>
#include <getopt.h>
#include "charset.h"
@

@<parse command line arguments@>=
int flags = 0;
while ((c = getopt(argc, argv, "SFdDeinq")) != -1) {
	switch (c) {
	case 'S':
		expect_success = true;
		break;
	case 'F':
		expect_failure = true;
		break;
	case 'd':
		dump_data = true;
		break;
	case 'D':
		flags |= CS_DOT;
		break;
	case 'e':
		flags |= CS_ESCAPES_ALLOWED;
		break;
	case 'i':
		flags |= CS_IGNORE_CASE;
		break;
	case 'n':
		flags |= CS_NO_NEWLINES;
		break;
	case 'q':
		quiet = true;
		break;
	case '?':
		usage(argv[0]);
		break;
	}
}

if (   (! expect_success && ! expect_failure)
    || (expect_success && expect_failure)) {
	fprintf(stderr, "You must give exactly one of -S or -F.\n");
	usage(argv[0]);
}
else if (optind + 2 > argc)	// no expr or no string provided
	usage(argv[0]);
@

@<test helper functions@>=
@<usage function@>
@

@<usage function@>=
/* usage --- print a usage message and die */

static void
usage(const char *name)
{
	fprintf(stderr, "Usage: %s -S|-F [-deinq] '[bracket-expression]'" \
					" '<string of characters>'\n",
			name);
	fprintf(stderr, "\t-S\tExpect match success.\n");
	fprintf(stderr, "\t-F\tExpect failure of some kind.\n");
	fprintf(stderr, "\t-d\tDump the data structure.\n");
	fprintf(stderr, "\t-D\tMatch \"dot\" (any character).\n");
	fprintf(stderr, "\t-e\tEscapes are allowed.\n");
	fprintf(stderr, "\t-i\tIgnore case.\n");
	fprintf(stderr, "\t-n\tNo newlines in [^...] or \"dot\".\n");
	fprintf(stderr, "\t-q\tRun quietly.\n");
	exit(EXIT_FAILURE);
}
@

@<compile the expression@>=
charset_t *bracket_expr;
int errcode = 0;

bracket_expr = parse_bracket_expr(argv[optind], flags, & errcode);
if (bracket_expr == NULL && expect_success) {
	fprintf(stderr, "bad expression: %s\n", errcode2string(errcode));
	// can't dump the data, return was NULL
	exit(EXIT_FAILURE);
}
@

@<test each wide character in the test case against the expression@>=
mbstate_t mbs;
memset(& mbs, 0, sizeof(mbs));
if (! quiet)
	printf("expect %s: %s: %s\n", expect_success ? "success" : "failure",
			argv[optind], argv[optind+1]);

int mb_cur_max = MB_CUR_MAX;
for (cp = argv[optind + 1]; *cp != '\0';) {
	size_t count;

	count = mbrtowc(& wc, cp, mb_cur_max, & mbs);
	if (count == (size_t) -1 || count == (size_t) -2) {
		count = 1;
		wc = *cp & 0xFF;
		cp++;	// skip over it and hope;
		memset(& mbs, 0, sizeof(mbs));	// reset the state
	} else
		cp += count;

	bool matched = charset_in_set(bracket_expr, wc);
	if (! matched && expect_success) {
		fprintf(stderr, "%s: failed to match L'%lc', success expected.\n", argv[optind], wc);
		@<dump the data if needed@>
		exit(EXIT_FAILURE);
	} else if (matched && expect_failure) {
		fprintf(stderr, "%s: succeeded to match L'%lc', failure expected.\n", argv[optind], wc);
		@<dump the data if needed@>
		exit(EXIT_FAILURE);
	}
}
@

@<dump the data if needed@>=
if (dump_data) {
	printf("escapes_allowed = %s\n",
			(flags & CS_ESCAPES_ALLOWED) != 0 ? "true" : "false");
	printf("ignore_case = %s\n",
			(flags & CS_IGNORE_CASE) != 0 ? "true" : "false");
	charset_dump(bracket_expr, stdout, false);
}
@

@<test helper functions@>=
/* errcode2string --- turn a charset error code into a string */

static const char *
errcode2string(int errcode)
{
	static char buf[100];
	static const char *messages[] = {
		"success",					// CSET_SUCCESS
		"bad pointer",				// CSET_EBADPTR
		"frozen set",				// CSET_EFROZEN
		"bad collation sequence",	// CSET_ECOLLATE
		"bad character class",		// CSET_ECTYPE
		"no memory",				// CSET_ESPACE
		"bad range",				// CSET_ERANGE
	};

	if (errcode < CSET_SUCCESS || errcode > CSET_ERANGE) {
		sprintf(buf, "unknown error code: %d", errcode);
		return buf;
	}

	return messages[errcode];
}
@

@node parsing the expression
@section Parsing The Bracket Expression

So, it seems that the hairiest part of setsearch was actually
the code to parse the bracket expression and build up the data
structure as it went along.  For the refactoring into this API,
that code isn't needed.  However, it turns out that it is
extremely useful for the test program!  So, we'll reuse it
here.  Be prepared, it's a big chunk of code.

Throughout, we need to be able to check for failure:

@<check for failure@>=
if (result != CSET_SUCCESS) {
	*errcode = result;
	goto fail;
}
@

@<test helper functions@>=
/* parse_bracket_expr --- convert a bracket expression into a charset_t */

static charset_t *
parse_bracket_expr(const char *expr, int flags, int *errcode)
{
	@<variables for parsing@>
	@<init variables for parsing@>
	bool ignore_case = (flags & CS_IGNORE_CASE) != 0;
	bool escapes_allowed = (flags & CS_ESCAPES_ALLOWED) != 0;
	bool no_newlines = (flags & CS_NO_NEWLINES) != 0;
	bool do_dot = (flags & CS_DOT) != 0;
	int result;

	if (expr == NULL) {
		if (errcode != NULL)
			*errcode = CSET_EBADPTR;
		return NULL;
	}

	charset_t *bracket_expr = charset_create(errcode);
	if (bracket_expr == NULL || *errcode != CSET_SUCCESS)
		return NULL;

	if (no_newlines)
		charset_set_no_newlines(bracket_expr, true);

	@<get a wide character@>
	if (a_wchar == L'.' && do_dot) {
		if (no_newlines) {
			result = charset_add_char(bracket_expr, L'\n');
			@<check for failure@>
		}
		result = charset_invert(bracket_expr);
		@<check for failure@>

		return bracket_expr;
	}

	if (a_wchar != L'[') {
		*errcode = CSET_ERANGE;	// not really right
		return NULL;
	}

	// main loop:
	while (cp < last) {
		@<get current wide character@>
		if (at_first_char && cur_wchar == L'^') {
			result = charset_invert(bracket_expr);
			@<check for failure@>

			// get the next character and then fall through
			@<get current wide character@>
		}

		if (! at_first_char && ! escaped && cur_wchar == L']')
			break;		// all done

		at_first_char = false;

		if (escaped)
			goto check_for_range;

		if (cur_wchar == L'[') {
			@<peek at next wide character@>
			if (wcschr(L":=.", next_wchar) == NULL)
				goto check_for_range_2;

			@<get current wide character@>
			@<process @code{[:...:]} items@>
			@<process @code{[=...=]} items@>
			@<process @code{[.X.]} items@>
		}

	check_for_range:

		@<peek at next wide character@>

	check_for_range_2:
		first_range_char_invalid = invalid;

		if (next_wchar == L'-') {
			wint_t first_wc, second_wc;

			first_wc = cur_wchar;
			// consume the '-'
			cp += n;

			// and get the second character
			@<peek at next wide character@>

			if (first_range_char_invalid || invalid /* 2nd range char */) {
				*errcode = CSET_ERANGE;
				goto fail;
			}

			if (next_wchar == L']') {
				// '-' was before terminating ']', treat literally
				result = charset_add_char(bracket_expr, first_wc);
				@<check for failure@>

				cur_wchar = L'-';
				goto push_wchar;
			} else {
				@<get current wide character@>
			}

			second_wc = cur_wchar;
			if (second_wc < first_wc) {
				*errcode = CSET_ERANGE;
				goto fail;
			}
			result = charset_add_range(bracket_expr, first_wc, second_wc);
			@<check for failure@>

			if (ignore_case) {
				if (iswlower(first_wc) && iswlower(second_wc))
					result = charset_add_range(bracket_expr, towupper(first_wc), towupper(second_wc));
				else if (iswupper(first_wc) && iswupper(second_wc))
					result = charset_add_range(bracket_expr, towlower(first_wc), towlower(second_wc));
				@<check for failure@>
			}

			continue;
		}

	push_wchar:
		// push cur_wchar onto wide character list
		result = charset_add_char(bracket_expr, cur_wchar);
		@<check for failure@>

		if (ignore_case) {
			if (iswlower(cur_wchar))
				result = charset_add_char(bracket_expr, towupper(cur_wchar));
			else if (iswupper(cur_wchar))
				result = charset_add_char(bracket_expr, towlower(cur_wchar));
			@<check for failure@>
		}
	}

	if (cur_wchar != L']') {
		*errcode = CSET_ERANGE;	// not perfect
		goto fail;
	}

	return bracket_expr;

fail:
	charset_free(bracket_expr);
	return NULL;
}
@

Here are the variables we need when working through
the expression using wide characters.

@<variables for parsing@>=
wint_t a_wchar, cur_wchar, next_wchar;
size_t n;
const char *cp, *last;
bool at_first_char = true;
bool escaped = false;
bool invalid = false;
bool first_range_char_invalid = false;
mbstate_t mbs;
size_t mb_cur_max = MB_CUR_MAX;
@

Initialization is obvious:

@<init variables for parsing@>=
cp = expr;
last = expr + strlen(expr);
memset(& mbs, 0, sizeof(mbs));
@

We need to get the current wide character and
advance @code{cp}. In so doing, we have to handle
escaped characters as well:

@<get current wide character@>=
@<get a wide character@>
if (escapes_allowed && a_wchar == L'\\') {
	@<get a wide character@>
	cur_wchar = a_wchar;
	at_first_char = false;
	escaped = true;
} else {
	escaped = false;
	cur_wchar = a_wchar;
}
@

This actually gets the next wide character:

@<get a wide character@>=
n = mbrtowc(& a_wchar, cp, mb_cur_max, & mbs);
if (n == (size_t) -1 || n == (size_t) -2) {
	// treat bad bytes as individual code points,
	// even if invalid and just skip over them.
	a_wchar = *cp & 0xFF;
	if (mb_cur_max > 1)
		invalid = true;
	n = 1;
	// after an invalid conversion, reinitialize mbsmbsp
	memset(& mbs, 0, sizeof(mbs));
}
cp += n;
@

And we also need to be able to peek ahead:

@<peek at next wide character@>=
n = mbrtowc(& next_wchar, cp, mb_cur_max, & mbs);
if (n == (size_t) -1 || n == (size_t) -2) {
	// here too, treat bad bytes as individual code points,
	// even if invalid and just skip over them.
	a_wchar = *cp & 0xFF;
	if (mb_cur_max > 1)
		invalid = true;
	n = 1;
	// after an invalid conversion, reinitialize mbs
	memset(& mbs, 0, sizeof(mbs));
}
// since we are peeking, we do NOT advance cp
@

@node ctype items
@subsection Handling Character Classes Like @code{[:alpha:]}

Now, it's time to deal with @code{[...[:alpha:]...]}.
POSIX allows for locales to have additional character classes
above and beyond the standard 12 classes available in every locale.
This means we have to ``nerd through'' the string to find the name,
copy it, and then look it up with with @code{wctype()}.  Sigh.

Even worse, since we're working with wide characters, we'll
have to convert what we find back to a multibyte string
before calling @code{wctype()}.

@<process @code{[:...:]} items@>=
if (cur_wchar == L':') {
	const char *the_name = NULL;

	if (! find_ctype_info(cp, & the_name,
			errcode, mb_cur_max, & mbs)) {
		if (the_name != NULL)
			free((void *) the_name);
		goto fail;
	}

	cp += strlen(the_name) + 2;	// +2 for closing :]
	result = charset_add_cclass(bracket_expr, the_name);
	if (result != CSET_SUCCESS) {
		if (the_name != NULL)
			free((void *) the_name);
		goto fail;
	}
	free((void *) the_name);	// it's copied inside charset_add_cclass

	continue;
}
@

@<test helper functions@>=
/* find_ctype_info --- fill in the info for a character class */

static bool
find_ctype_info(const char *cp,
                const char **the_name, int *errcode,
                size_t mb_cur_max, mbstate_t *mbsp)
{
	const char *begin = cp;
	size_t len = strlen(cp);
	const char *last = cp + len;
	char *name_buf;
	wchar_t *w_name_buf;
	wchar_t *namep = NULL;
	wint_t a_wchar;
	size_t n;
	bool invalid = false;
// This is a hack, but it's "just" test code
#define mbs	(*mbsp)

	w_name_buf = (wchar_t *) malloc((len + 1) * sizeof(wchar_t));
	if (w_name_buf == NULL) {
		*errcode = CSET_ESPACE;
		return false;
	}
	memset(w_name_buf, 0, (len + 1) * sizeof(wchar_t));

	for (namep = w_name_buf; cp < last;) {
		@<get a wide character@>
		if (a_wchar == L':') {
			break;
		}
		*namep++ = a_wchar;
	}

	*namep = L'\0';
	@<get a wide character@>
	if (a_wchar != L']') {
		*errcode = CSET_ECTYPE;
		free(w_name_buf);
		return false;
	}

	name_buf = (char *) malloc(len + 1);
	if (name_buf == NULL) {
		*errcode = CSET_ESPACE;
		free(w_name_buf);
		return false;
	}
	memset(name_buf, 0, len + 1);

	mbstate_t mbs2;	// use a separate mbstate_t
	memset(& mbs2, 0, sizeof(mbs2));
	const wchar_t *name_start = w_name_buf;
	wcsrtombs(name_buf, & name_start, len + 1, & mbs2);

	*the_name = name_buf;
	free(w_name_buf);

	*errcode = CSET_SUCCESS;

	return true;
#undef mbs
}
@

@node Equivalence Classes and Collating Elements
@subsection Handling Equivalence Classes and Collating Elements

The first step for an equivalence class is to extract
the wide character and make sure it has the closing @samp{=]}.

@<process @code{[=...=]} items@>=
if (cur_wchar == L'=') {
	wint_t the_wc;
	const char *begin = cp;

	@<get current wide character@>
	the_wc = cur_wchar;

	@<peek at next wide character@>
	if (next_wchar != L'=') {
		*errcode = CSET_ECTYPE;	// not really right
		goto fail;
	}
	// consume the '='
	cp += n;
	@<peek at next wide character@>
	if (next_wchar != L']') {
		*errcode = CSET_ECTYPE;	// not really right
		goto fail;
	}
	// consume the ']'
	cp += n;

	result = charset_add_equiv(bracket_expr, the_wc);
	@<check for failure@>
	if (ignore_case) {
		if (iswlower(the_wc))
			result = charset_add_equiv(bracket_expr, towupper(the_wc));
		else if (iswupper(the_wc))
			result = charset_add_equiv(bracket_expr, towlower(the_wc));
		@<check for failure@>
	}

	continue;
}
@

We allow single character collating elements:

@<process @code{[.X.]} items@>=
if (cur_wchar == L'.') {
	wint_t the_wc;
	const char *begin = cp;

	@<get current wide character@>
	the_wc = cur_wchar;

	@<peek at next wide character@>
	if (next_wchar != L'.') {
		*errcode = CSET_ECOLLATE;
		goto fail;
	}
	// consume the '.'
	cp += n;
	@<peek at next wide character@>
	if (next_wchar != L']') {
		*errcode = CSET_ECOLLATE;
		goto fail;
	}
	// consume the ']'
	cp += n;

	result = charset_add_char(bracket_expr, the_wc);
	@<check for failure@>

	if (ignore_case) {
		if (iswlower(the_wc))
			result = charset_add_char(bracket_expr, towupper(the_wc));
		else if (iswupper(the_wc))
			result = charset_add_char(bracket_expr, towlower(the_wc));
		@<check for failure@>
	}

	continue;
}
@

@node test driver
@section The Test Program Driver Script

The idea is to have a text file containing tests, and a shell
script to read the tests and call @command{btest} appropriately.
The text file will have three columns separated by tabs:

@enumerate
@item
The command line options. At the very least one of @option{-F} or @option{-S}.

@item
The bracket expression.

@item
One or more characters to test against the bracket expression.
@end enumerate

Lines that start with @samp{#} are comment lines and are ignored, as are
empty lines.
We rely on Bash's special @code{$'@dots{}'} string notation to include TAB
characters instead of using physical TAB characters in the file.

@(runtests.sh@)=
#! /bin/bash

TESTFILE=${1:-testdata.txt}

sed -e $'/^[ \t]*#/d' -e $'/^[ \t]*$/d' $TESTFILE |
	while IFS=$'\t' read options expr chars
	do
		./btest $options "$expr" "$chars"
		echo
	done
@
@post_create runtests.sh chmod +x runtests.sh

We rely on the @file{Makefile} to save the results and compare them
to known good results.

For now, the test data and @file{Makefile} are not included in this document.

@node Generating Ranges
@chapter Generating Ranges To Replace The @code{*ctype()} Functions

Towards the end of 2024 and beginning of 2025, we found that,
for some additional work being done in MinRX, it won't be
possible to rely on the @code{*ctype()} routines. Instead, it will
be necessary to manually build the sets of characters that match
@code{[:alpha:]}, @code{[:lower:]}, and so on, by looping through all
the Unicode code points and testing them.
The charset code is
perfect for turning large sets of values into smaller sets of ranges,
which can then be easily added to a charset under construction.

With a new program to generate the ranges, and a small change to the
@code{charset_dump()} function, this becomes straightforward.
In this chapter, we write the new program.

@(genranges.c@)=
@<Copyright statement@>

@<genranges includes@>

@<genranges declarations@>
@<genranges globals@>

/* main --- process args */

int
main(int argc, char **argv)
{
	int i;

	if (argc == 1)
		usage(argv[0]);	// will exit

	for (i = 1; i < argc; i++)
		process(argv[i]);

	return EXIT_SUCCESS;
}

@<genranges usage function@>
@<process function@>
@

@<genranges includes@>=
#include <stdio.h>
#include <errno.h>
#include <locale.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <wctype.h>

#include "charset.h"
@

@<genranges declarations@>=
extern void process(const char *locale_name);
extern void usage(const char *progname);
@

@<genranges usage function@>=
/* usage --- print usage message and exit with error */

void
usage(const char *progname)
{
	fprintf(stderr, "usage: %s locale-name ...\n", progname);

	exit(EXIT_FAILURE);
}
@

@<genranges globals@>=
static const int max_unicode = 0x10FFFF;
@

We will need a data structure to use for
finding the different ranges:

@<typeinfo array@>=
static struct typeinfo {
	const char *name;
	wctype_t	type;
	charset_t *cset;
	FILE *fp;
} types[] = {
	{ "alnum", 0, NULL, NULL },
	{ "alpha", 0, NULL, NULL },
	{ "blank", 0, NULL, NULL },
	{ "cntrl", 0, NULL, NULL },
	{ "digit", 0, NULL, NULL },
	{ "graph", 0, NULL, NULL },
	{ "lower", 0, NULL, NULL },
	{ "print", 0, NULL, NULL },
	{ "punct", 0, NULL, NULL },
	{ "space", 0, NULL, NULL },
	{ "upper", 0, NULL, NULL },
	{ "xdigit", 0, NULL, NULL },
	{ NULL, 0, NULL, NULL },
};
@

@<process function@>=
/* process --- for a given locale, generate the ranges for the various ctypes */

void
process(const char *localename)
{
	char buf[BUFSIZ];
	int i;
	int32_t c;
	@<typeinfo array@>

	if (mkdir(localename, 0755) < 0 && errno != EEXIST) {
		fprintf(stderr, "%s: could not make directory: %s\n",
			localename, strerror(errno));
		exit(EXIT_FAILURE);
	}

	setlocale(LC_ALL, localename);

	@<initialize types array@>

	// loop over all the characters once
	for (c = 0; c < max_unicode; c++) {
		// check the character if it matches any of the ctypes
		for (i = 0; types[i].name != NULL; i++) {
			if (iswctype(c, types[i].type))
				(void) charset_add_char(types[i].cset, c);
		}
	}

	// dump the ranges
	for (i = 0; types[i].name != NULL; i++) {
		// test a char to finalize the range
		(void) charset_in_set(types[i].cset, L'A');

		// dump the range
		fprintf(types[i].fp, "static struct char_range %s[] = {\n", types[i].name);
		charset_dump(types[i].cset, types[i].fp, true);
		fprintf(types[i].fp, "\t{ -1, -1 },\t// end markers\n");
		fprintf(types[i].fp, "};\n");
		fclose(types[i].fp);
		charset_free(types[i].cset);

		types[i].type = 0;
		types[i].fp = NULL;
		types[i].cset = NULL;
	}
}
@

@<initialize types array@>=
for (i = 0; types[i].name != NULL; i++) {
	FILE *fp;

	sprintf(buf, "%s/%s", localename, types[i].name);
	if ((fp = fopen(buf, "w")) == NULL) {
		fprintf(stderr, "%s: could not open: %s\n",
			buf, strerror(errno));
		exit(EXIT_FAILURE);
	}

	types[i].fp = fp;
	types[i].type = wctype(types[i].name);
	int errcode = 0;
	types[i].cset = charset_create(& errcode);
}
@

@node Commentary
@chapter Commentary

@itemize @bullet
@item
The idea for the data structure was undoubtedly inspired by Russ Cox's
@uref{https://github.com/google/re2, @code{libre2}}, which uses a balanced
binary tree of ranges for handling bracket expressions.

In terms of searching, I expect the two data structures have the same
``big O'' complexity; my data structure saves the additional space overhead
of left and right subtree pointers.  Inserting into a balanced binary
tree is more complicated than my method of building the structure and then
sorting and uniquing it; however the binary tree won't insert something
that is already there.

In practice, I think it doesn't matter, as (a) most bracket expressions
are very simple and not pathological, and (b) when processing lots of
data, the amount of time spent building the data structure (compiling
the regular expression) gets lost down in the noise compared to the
amount of time spent executing it.

@item
One thing I've noticed a lot about Literate Programming is that
inlined chunks end up being used when more conventional programming
would dictate the use of a function (in C or @command{awk}) or
a macro (in C).  In particular, I sometimes miss the ability
to parameterize the objects a code chunk operates upon.

It then becomes a question: once the code is complete, should I
go back and modify things to use macros or functions? I think it
depends upon if the generated code will be what's maintained
going forward, or if the literate code will remain the main ``source''.
Thus, at least for now, the question remains open.

@item
The exercise of reworking existing code under a new API (from setsearch to charset)
has been interesting. I think the Literate Programming style has helped a lot.
I was able to copy/paste both code and prose into their places, adjusting the
code as needed, with very little trouble. In particular, the amount of reuse
is quite high, which is very pleasing.

@item
I wrote the @file{charset.3} manpage first. (It can be found in
the Github repository.) It went through several iterations before I was
happy with it. Doing so was a good idea; it helped me clarify and
simplify the API, and thus the implementation as well.

@item
I remain pleased with the underlying data structure. It is unchanged
from setsearch, as is the way it's built and searched.
@end itemize


@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
