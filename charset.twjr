\input texinfo   @c -*-texinfo-*-
@c vim: filetype=texinfo tabstop=4 shiftwidth=4
@c %**start of header (This is for running Texinfo on a region.)
@setfilename charset.info
@settitle Efficient Searching of Large Character Sets --- Take Two
@c %**end of header (This is for running Texinfo on a region.)

@c Change how xref titles are quoted.
@dquotexrefs
@ifclear FORPRINT
@pdflinkcolor
@urllinkcolor
@hideurls
@end ifclear


@c The following information should be updated here only!
@c This sets the edition of the document.

@c These apply across the board.
@set UPDATE-MONTH November, 2024
@set EDITION 0.1

@set TITLE Efficient Searching of Large Character Sets --- Take Two
@set SHORTTITLE Searching Character Sets

@iftex
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end iftex
@ifhtml
@set DOCUMENT Web page
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifhtml
@ifinfo
@set DOCUMENT Info file
@set CHAPTER major node
@set APPENDIX major node
@set SECTION minor node
@set SUBSECTION node
@end ifinfo
@ifdocbook
@set DOCUMENT book
@set CHAPTER chapter
@set APPENDIX appendix
@set SECTION section
@set SUBSECTION subsection
@end ifdocbook

@c some special symbols
@ifnottex
@macro ii{text}
@i{\text\}
@end macro
@end ifnottex

@c Uncomment this if you want the metafont logo.
@ignore
@ifnottex
@macro MF{}
@sc{METAFONT}
@end macro
@end ifnottex
@end ignore

@c merge the function and variable indexes into the concept index
@c do so without the code font, and in the index entries do the
@c font management ourselves.  Also merge in the chunk definition
@c and reference entries, which jrweave creates for us.
@ifnothtml
@synindex fn cp
@synindex vr cp
@synindex cd cp
@synindex cr cp
@end ifnothtml

@c If "finalout" is commented out, the printed output will show
@c black boxes that mark lines that are too long.  Thus, it is
@c unwise to comment it out when running a master in case there are
@c overfulls which are deemed okay.

@iftex
@c @finalout
@end iftex

@copying
@docbook
<para>Published by:</para>

<literallayout class="normal">Arnold David Robbins
P.O. Box 354
Nof Ayalon 9978500
ISRAEL
Email: <email>arnold@@skeeve.com</email>
URL: <ulink url="https://www.skeeve.com/">https://www.skeeve.com/</ulink></literallayout>

<literallayout class="normal">Copyright &copy; 2024
Arnold David Robbins
All Rights Reserved.</literallayout>
@end docbook

@ifnotdocbook
Copyright @copyright{} 2024 @*
Arnold David Robbins @*
All Rights Reserved.
@end ifnotdocbook
@sp 1
The charset program is copyright
@copyright{} 2024 by Arnold David Robbins.
@c It is published under the conditions of a BSD license yet to be determined.
Not for publication, yet.
@sp 2
This is Edition @value{EDITION} of @cite{@value{TITLE}}.
@end copying

@c Uncomment this for the release.  Leaving it off saves paper
@c during editing and review.
@c @setchapternewpage odd

@c Uncomment this if it's ever printed as a real book(let).
@c @shorttitlepage @value{SHORTTITLE}

@titlepage
@title @value{TITLE}
@subtitle @value{UPDATE-MONTH}
@author Arnold David Robbins

@ifnotdocbook
@c Include the Distribution inside the titlepage environment so
@c that headings are turned off.  Headings on and off do not work.

@page
@vskip 0pt plus 1filll
Published by:
@sp 1
Arnold David Robbins @*
P.O. Box 354 @*
Nof Ayalon 9978500 @*
ISRAEL @*
Email: @EMAIL{arnold@@skeeve.com,arnold AT skeeve.com} @*
URL: @url{https://www.skeeve.com/} @*

@insertcopying
@end ifnotdocbook
@end titlepage

@set DRAFT

@iftex
@headings off
@evenheading @thispage @| @value{DRAFT} @| @strong{@value{SHORTTITLE}}
@oddheading  @strong{@thischapter} @| @value{DRAFT} @| @thispage
@end iftex

@ifnottex
@ifnotdocbook
@ifnotxml
@node Top
@top General Introduction
@c Preface node should come right after the Top
@c node, in `unnumbered' sections, then the introductory chapter.
@c Licensing nodes are appendices, they're not central to TexiWebJr.

This file documents @code{charset}, a set of functions that accept
a wide character value and search a defined set of characters to
see if the value is in the set.  It is intended for use within
a regular expression matching library.

@insertcopying
@end ifnotxml
@end ifnotdocbook
@end ifnottex

@menu
@detailmenu
@end detailmenu
@end menu

@c @summarycontents
@contents

@c Add these to the menu if they ever get included.
@c @node Foreword
@c @unnumbered Foreword

@node Preface
@unnumbered Preface

This @value{DOCUMENT} documents @code{charset}, a set of functions that accept
a wide character value and search a defined set of characters to
see if the value is in the set.  It is intended for use within
a regular expression matching library.

@menu
* Audience::                    Who should read this @value{DOCUMENT}.
* Conventions::                 Typographical conventions.
* Acknowledgements::            Acknowledgements.
@end menu

@node Audience
@unnumberedsec Intended Audience

If you're interested in one way to search bracket expressions for
a matching character value when using very large character sets
(such as Unicode), you should read this @value{DOCUMENT}.

@node Conventions
@unnumberedsec Typographical Conventions

@c Copied mostly verbatim from the gawk manual.

@cindex Texinfo document formatting language
This @value{DOCUMENT} is written in an enhanced version of
@uref{https://www.gnu.org/software/texinfo/, Texinfo},
the GNU documentation formatting language.
A single Texinfo source file is used to produce both the printed and online
versions of a program's documentation.
@ifnotinfo
Because of this, the typographical conventions
are slightly different than in other books you may have read.
@end ifnotinfo

Examples you would type at the command-line are preceded by the common
shell primary and secondary prompts, @samp{$} and @samp{>}.  Input that
you type is shown @kbd{like this}.  Output from the command is preceded
by the glyph ``@print{}''.  This typically represents the command's
standard output.  Error messages, and other output on the command's
standard error, are preceded by the glyph ``@error{}''.  For example:

@example
$ @kbd{echo hi on stdout}
@print{} hi on stdout
$ @kbd{echo hello on stderr 1>&2}
@error{} hello on stderr
@end example

@ifnotinfo
In the text, command names appear in @code{this font}, while code segments
appear in the same font and quoted, @samp{like this}.  Options look
like this: @option{-f}.  Some things are emphasized @emph{like this},
and if a point needs to be made strongly, it is done @strong{like this}.
The first occurrence of a new term is usually its @dfn{definition} and
appears in the same font as the previous occurrence of ``definition''
in this sentence.  Finally, file names are indicated like this:
@file{/path/to/our/file}.
@end ifnotinfo

@node Acknowledgements
@unnumberedsec Acknowledgements

Thanks to Mike Haertel for his feedback, and for giving me the
opportunity to write this bit of code.

@node Introduction
@chapter Introduction

In the fall of 2023, Mike Haertel started writing a new regular expression library,
@uref{https://github.com/mikehaertel/minrx, MinRX},
with the aim of eventually replacing the matchers in use by GNU Awk
(@command{gawk}).  The initial version is in C++; it will eventually be translated
to C for portability. As of August 2024, it's working fully.

As part of the discussion between Mike and myself, I offered a rough draft of a
data structure to use for quickly seeing if a character matches a @dfn{bracket expression},
which is a construct used within regular expressions to represent sets of different
kinds of characters to be matched.
The ideas for this data structure and how to use it had been bouncing around in
my head for some time.

I initially wrote a library---setsearch---that parsed bracket expressions,
built the data structure, and then used it. It's still available at
@uref{https://github.com/arnoldrobbins/setsearch}.  However, further discussion
with Mike revealed that what he really needed was just a data structure for
storing sets of characters and testing an input character against the set;
he preferred to do his own parsing of the bracket expression, and add characters
to the set as needed.

As a result, I designed a new API that still uses the same underlying
data structures. Thus, this @value{DOCUMENT} presents the design and
implementation of a sublibrary (so to speak) for dealing with character
sets.
Almost all of the original setsearch code and literate
documentation are reused here, but in a different way.
In particular, the code for parsing a bracket expression will
come in handy for the test program.

The machine-readable files are available from GitHub. The steps
necessary to get them are:

@example
git clone https://github.com/arnoldrobbins/charset
cd charset
vim jrweave jrtangle    # or emacs :-). Set the path to gawk
make
@end example

@noindent
In order to format the document,
you will need to have @TeX{} and Texinfo installed,
including @command{texi2pdf}.  Or you can ask me for
a PDF, if necessary.

@node The Data Structure
@chapter The Underlying Data Structure

We'll start with the underlying data structure and how
it's searched, and then move on to how it's built
and the API that manages it.

A single item in the set is represented by
a set item:

@<data structures@>=
typedef struct set_item {
	enum set_item_type {
		CTYPE_ITEM,
		RANGE_ITEM,
	} item_type;
	union {
		struct _ctype {
			wctype_t    wtype;
			const char *type_name;
		} c;
		struct _range {
			int32_t start, end;
		} r;
	} u;
} set_item;
#define wtype		u.c.wtype
#define type_name	u.c.type_name
#define start		u.r.start
#define end			u.r.end
@

A @code{set_item} holds one of two things:

@itemize @bullet
@item Information needed for use with the @code{iswctype()} function.
This consists of a value of type @code{wctype_t}, and a pointer to
a string representing the ctype.

@item A range, such as @code{[a-z]}.
Single characters that
aren't contiguous with others are placed in a range where
@code{start} and @code{end} are set to the same value.
@end itemize

The full @code{charset_t} holds a dynamically allocated
array of @code{set_item}s, items needed for building
the set, and what's needed for managing
the memory:

@<data structures@>=
struct _charset {
	bool     complemented;      // For [^...] sets
	bool     no_newlines;       // For dumping
	bool     finalized;         // No more changes possible
	size_t   nchars_inuse;      // Number of characters used
	size_t   nchars_allocated;  // Number of characters allocated
	int32_t  *chars;            // Characters added to the set
	size_t   nelems;            // Number of elements in use
	size_t   allocated;         // Number allocated.
	set_item *items;            // Array of items
};
@

@node Error Codes
@chapter Error Codes

Almost all of the functions return a success or error value via a
pointer to a plain integer. Here are the error codes:

@<error codes@>=
// error code values:
enum {
	CSET_SUCCESS = 0,		// no problems
	CSET_EBADPTR,		// NULL pointer received
	CSET_EFROZEN,		// Cannot add more characters to the set
	CSET_ECOLLATE,		// corresponds to REG_ECOLLATE
	CSET_ECTYPE,		// corresponds to REG_ECTYPE
	CSET_ESPACE,		// corresponds to REG_ESPACE
};
@

@node The Easy Stuff
@chapter The Easy Functions

Let's get the easier functions out of the way.
A fundamental assumption is that the array of items
is sorted and uniqued. In addition, all @code{CTYPE_ITEM}s
are at the front of the array, so that they can be tested
first.

@<API functions@>=
/* charset_in_set --- see if a character is in the set */

bool
charset_in_set(const charset_t *set, int32_t the_char, int *errcode)
{
	@<check for NULL pointers@>
	*errcode = CSET_SUCCESS;

	if (! set->finalized)
		finalize(set, errcode);

	if (*errcode != CSET_SUCCESS)	// finalize() failed
		return false;

	if (the_char == L'\n' && set->no_newlines && set->complemented)
		return false;

	bool found = is_found(set, the_char);
	if (set->complemented)
		found = ! found;		// reverse sense of the match

	return found;
}

/* charset_free --- free all storage */

bool
charset_free(const charset_t *set, int *errcode)
{
	@<check for NULL pointers@>

	for (int i = 0; i < set->nelems; i++) {
		if (set->items[i].item_type == CTYPE_ITEM)
			free((void *) set->items[i].type_name);
		else
			break;
	}

	if (set->chars != NULL)
		free((void *) set->chars);

	free((void *) set->items);
	free((void *) set);

	*errcode = CSET_SUCCESS;
	return true;
}
@

We check for @code{NULL} pointers in every function:

@<check for NULL pointers@>=
if (set == NULL) {
	if (errcode != NULL)
		*errcode = CSET_EBADPTR;
	return false;
}
@

@<API declarations@>=
bool charset_in_set(const charset_t *set, int32_t the_char, int *errcode);
bool charset_free(const charset_t *set, int *errcode);
@

@node Searching
@section Searching For A Character

The actual searching is separate from the ``is complemented'' test to
keep things simple.

@<helper functions@>=
@<item comparison functions@>

/* is_found --- return true if the character is found */

static bool
is_found(const charset_t *set, int32_t the_char)
{
	set_item *items = brack_expr->items;
	int i;

	@<Special case search for only one item in the set@>
	@<Search for a @code{CTYPE_ITEM}@>
	@<Search for a @code{RANGE_ITEM}@>
}
@

The @code{CTYPE_ITEM}s are checked before the @code{RANGE_ITEM}s, since
each one can match multiple characters with a single function call:

@<Search for a @code{CTYPE_ITEM}@>=
for (i = 0; i < set->nelems; i++) {
	// linear search of ctype items
	if (items[i].item_type == RANGE_ITEM)
		break;

	assert(items[i].item_type == CTYPE_ITEM);
	if (iswctype(the_char, items[i].wtype))
		return true;
}

if (i >= set->nelems)
	return false;
@

Searching for a matching @code{RANGE_ITEM} is
done using binary search:

@<Search for a @code{RANGE_ITEM}@>=
assert(set[i].item_type == RANGE_ITEM);

// binary search to see if we have it
set_item *found;
set_item key;
key.item_type = RANGE_ITEM;
key.start = key.end = the_char;

found = bsearch(& key, set + i, set->nelems - i,
				sizeof(set_item), item_compare_for_searching);

return found != NULL;
@

We need the header file for assertions:

@<includes@>=
#include <assert.h>
@

As a special case, if the set has only one character
in it, we avoid the overhead of binary search:

@<Special case search for only one item in the set@>=
if (set->nelems == 1
    && set->items[0].item_type == RANGE_ITEM
    && set->items[0].start <= the_char
	&& the_char <= set->items[0].end)
	return true;
@

We need two comparison functions: one for use by @code{bsearch()} and
a different one for use by by @code{qsort()}.  We
want @code{CTYPE_ITEM}s to sort to the front of the list.  For sorting,
we sort the @code{RANGE_ITEM}s based on their @code{start} value.
For searching, we have to compare with the value in @code{key},
and we will only be looking at @code{RANGE_ITEM}s.

The comparisons are fundamentally different. When sorting,
we're comparing array elements against each other. When
searching, we compare elements one at a time against a key.
The sorting comparison is more elaborate:

@<item comparison functions@>=
/* item_compare_for_sorting --- compare two set_items */

static int
item_compare_for_sorting(const void *l, const void *r)
{
	set_item *left = (set_item *) l;
	set_item *right = (set_item *) r;

	if (left->item_type == CTYPE_ITEM && right->item_type == CTYPE_ITEM) {
		return left->wtype - right->wtype;
	} else if (left->item_type == CTYPE_ITEM && right->item_type == RANGE_ITEM) {
		return -1;
	} else if (left->item_type == RANGE_ITEM && right->item_type == CTYPE_ITEM) {
		return +1;
	} else {
		assert(left->item_type == RANGE_ITEM && right->item_type == RANGE_ITEM);
		return left->start - right->start;
	}
}
@

The searching function is simpler.  POSIX tells us that the first
argument is the key and the second is the array element being
compared.

@<item comparison functions@>=
/* item_compare_for_searching --- compare two set_items */

static int
item_compare_for_searching(const void *k, const void *e)
{
	set_item *thekey = (set_item *) k;
	set_item *elem = (set_item *) e;

	assert(thekey->item_type == RANGE_ITEM && elem->item_type == RANGE_ITEM);

	if (elem->start <= thekey->start && thekey->start <= elem->end)
		return 0;	// found it
	else if (thekey->end < elem->start)
		return -1;
	else {
		assert(thekey->start > elem->end);
		return 1;
	}
}
@

@node Printing
@section Printing The Data Structure

Printing the data is straightforward.

@<API functions@>=
/* charset_dump --- dump out the data structures */

void
charset_dump(const charset_t *set, FILE *fp)
{
	static const char *boolval[] = {
		"false",
		"true",
	};

	if (set == NULL || fp == NULL)
		return;

	fprintf(fp, "finalized = %s\n", boolval[!! set->finalized]);
	fprintf(fp, "no_newlines = %s\n", boolval[!! set->no_newlines]);

	set_item *items = set->items;
	for (int i = 0; i < set->nelems; i++) {
		if (items[i].item_type == CTYPE_ITEM) {
			fprintf(fp, "%3d. CTYPE: [:%s:]\n", i, items[i].type_name);
			continue;
		}
		assert(items[i].item_type == RANGE_ITEM);
		fprintf(fp, "%3d. RANGE: start = L'%lc', end = L'%lc'\n",
			i, items[i].start, items[i].end);
	}
	fflush(fp);
}
@

@<API declarations@>=
void charset_dump(const charset_t *set, FILE *fp);
@

@node API Functions
@chapter API Functions

Here are the functions for the API.

@node Creating The Charset
@section Creating The Charset

Creating the character set simply
allocates the memory and forces it to zero.
Then we check the flags.

@<API declarations@>=
typedef enum {
	CSET_NO_FLAGS = 0,	// no special cases
	CSET_NO_NEWLINE = 0x01,	// \en not allowed in inverted range or "all chars"
	// other flags may be added if needed
} charset_flags_t;
@


@<API functions@>=
/* charset_create --- make a new charset_t and initialize it */

charset_t *
charset_create(charset_flags_t flags, int *errcode)
{
	if (errcode == NULL)
		return NULL;

	charset_t *set = (charset_t *) malloc(sizeof(charset_t));
	if (set == NULL) {
		*errcode = CSET_ESPACE;
		return NULL;
	}

	memset(set, 0, sizeof(charset_t));

	if ((flags & CSET_NO_NEWLINE) != 0)
		set->no_newlines = true;

	*errcode = CSET_SUCCESS;
	return set;
}
@

@<API declarations@>=
charset_t *charset_create(charset_flags_t flags, int *errcode);
@

@node Adding A Character
@section Adding A Character

@<API functions@>=
/* charset_add_char --- add a single wide character to the set */

bool
charset_add_char(charset_t *set, int32_t wc, int *errcode)
{
	@<check for NULL pointers@>
	@<check if finalized@>

	@<create or grow the array of wide characters@>

	set->chars[set->nchars_inuse++] = wc;
	set->chars[set->nchars_inuse] = L'\0';	// make it into a string
	return true;
}
@


@<check if finalized@>=
if (set->finalized) {
	*errcode = CSET_EFROZEN;
	return false;
}
@

@<create or grow the array of wide characters@>=
if (set->chars == NULL) {
	set->chars = (int32_t *) malloc(sizeof(int32_t * 10));
	if (set->chars == NULL) {
		*errcode = CSET_ESPACE;
		return false;
	}
	set->nchars_allocated = 10;
	set->nchars_inuse = 0;
} else if (set->nchars_inuse + 1 >= set->nchars_allocated) {
	int new_amount = set->nchars_allocated * 2;
	int32_t *new_data = (int32_t *) realloc(set->chars, new_amount * sizeof(int32_t));

	if (new_data == NULL) {
		*errcode = CSET_ESPACE;
		return false;
	}
	memset(new_data + set->nchars_allocated, 0, set->nchars_allocated * sizeof(int32_t));
	set->nchars_allocated = new_amount;
	set->chars = new_data;
}
@

@<API declarations@>=
bool charset_add_char(charset_t *set, int32_t wc, int *errcode);
@

@node Adding Ranges
@section Adding Ranges

@<API functions@>=
/* charset_add_range --- add a range item */

bool
charset_add_range(charset_t *set, int32_t start, int32_t end, int *errcode)
{
	@<check for NULL pointers@>
	@<check if finalized@>

	@<create or grow the set of items if necessary@>

	set_item new_item;
	new_item.item_type = RANGE_ITEM;
	new_item.start = first;
	new_item.end = last;
	set->items[set->nelems++] = new_item;

	return true;
}
@

@<create or grow the set of items if necessary@>=
if (set->items == NULL) {
	set->items = (set_item *) malloc(sizeof(set_item * 10));
	if (set->items == NULL) {
		*errcode = CSET_ESPACE;
		return false;
	}
	set->allocated = 10;
	set->nelems = 0;
} else if (set->nelems + 1 >= set->allocated) {
	int new_amount = set->allocated * 2;
	set_item *new_data = (set_item *) realloc(set->items, new_amount * sizeof(set_item));

	if (new_data == NULL) {
		*errcode = CSET_ESPACE;
		return false;
	}
	memset(new_data + set->allocated, 0, set->allocated * sizeof(set_item));
	set->allocated = new_amount;
	set->items = new_data;
}
@

@<API functions@>=
/* charset_add_all_chars --- make a range with all possible characters */

bool
charset_add_all_chars(charset_t *set, int *errcode)
{
	@<check for NULL pointers@>
	@<check if finalized@>

	if (set->no_newlines) {
		if (! charset_add_range(set, 0, L'\n' - 1, errcode))
			return false;
		if (! charset_add_range(set, L'\n' + 1, 0x10ffff, errcode))
			return false;
	} else {
		if (! charset_add_range(set, 0, 0x10ffff, errcode))
			return false;
	}

	return true;
}
@

@<API declarations@>=
bool charset_add_range(charset_t *set, int32_t start, int32_t end, int *errcode);
bool charset_add_all_chars(charset_t *set, int *errcode);
@

@node Inverting
@section Inverting The Charset


@<API functions@>=
bool charset_invert(charset_t *set, int *errcode)
{
	@<check for NULL pointers@>
	@<check if finalized@>

	set->inverted = true;
	return true;
}
@

@<API declarations@>=
bool charset_invert(charset_t *set, int *errcode);
@

@node The Funky Stuff
@chapter Character Classes, Equivalence Classes, and Collating Sequences

@node Character Classes
@section  Character Classes

@<API functions@>=
bool charset_add_cclass(charset_t *set, const char *cclass, int *errcode)
{
	@<check for NULL pointers@>
	@<check if finalized@>

	@<create or grow the set of items if necessary@>

	wctype_t the_type = wctype(cclass);
	if (the_type == 0) {	// not a known class name
		*errcode = CSET_ECTYPE;
		return false;
	}

	const char *class_name = strdup(cclass);
	if (class_name == NULL) {
		*errcode = CSET_ESPACE;
		return false;
	}
	set_item new_item;
	new_item.item_type = CTYPE_ITEM;

	new_item.wtype = the_type;
	new_item.type_name = class_name;
	set->items[set->nelems++] = new_item;

	return true;
}
@

@<API declarations@>=
bool charset_add_cclass(charset_t *set, const char *cclass, int *errcode);
@

@node Equivalence Classes
@section Equivalence Classes

Here is Mike's portable but ``sleazy'' (sic) way to add all
the equivalent characters:

@<API functions@>=
bool charset_add_equiv(charset_t *set, int32_t equiv, int *errcode)
{
	@<check for NULL pointers@>
	@<check if finalized@>

	wchar_t wcs_in[2];
	wchar_t wcs[2];
	wchar_t abuf[100], wbuf[100];

	wcs_in[0] = equiv;
	wcs_in[1] = 0;
	wcsxfrm(abuf, wcs_in, 99);
	wcs[1] = 0;
	for (wchar_t u = 1; u < 0x110000; ++u) {
		wcs[0] = u;
		wcsxfrm(wbuf, wcs, 99);
		if (abuf[0] == wbuf[0])
			if (! charset_add_char(set, u, errcode))
				return false;
	}

	return true;
}
@

@<API declarations@>=
bool charset_add_equiv(charset_t *set, int32_t equiv, int *errcode);
@

@node Collating Sequences
@section  Collating Sequences

@<API functions@>=
bool charset_add_collate(charset_t *set, const int32_t *collate, int *errcode)
{
	@<check for NULL pointers@>
	@<check if finalized@>

	// only single character collating sequences allowed,
	// at least right now
	if (collate[1] != L'\0') {
		*errcode = CSET_ECOLLATE;
		return false;
	}

	return charset_add_char(set, collate[0], errcode);
}
@

@<API declarations@>=
bool charset_add_collate(charset_t *set, const int32_t *collate, int *errcode);
@

@node Finalizing
@chapter Finalizing The Charset

@node Source Files
@section Source Files

@(charset.h@)=
#ifndef CHARSET_H
#define CHARSET_H 1

@<Copyright statement@>

#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _charset charset_t;

@<error codes@>
@<API declarations@>

#ifdef __cplusplus
}
#endif
#endif /* CHARSET_H */
@

@(charset.c@)=
@<Copyright statement@>

@<includes@>
#include "charset.h"	// for the charset_t typedef
@<deal with @code{gettext()}@>

@<data structures@>
@<helper functions@>
@<API functions@>
@

To get it out of the way, here is the copyright statement.

@<Copyright statement@>=
// Copyright (C) 2024, Arnold David Robbins.
// All rights reserved.  Not for redistribution (yet...).
@

We include the standard header files that we'll need:

@<includes@>=
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>
//#include <stdlib.h>
#include <string.h>
@

Since we want the error messages to be translatable,
we have deal with @code{gettext()}:

@<deal with @code{gettext()}@>=
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif

#ifdef HAVE_GETTEXT_H
#include "gettext.h"
#define _(x) gettext(x)
#else
#define _(x) x
#endif
@

@node Test Program
@chapter A Test Program

@node First appendix
@appendix First Appendix Title

@node Code Chunk Summaries
@appendix Code Chunk Summaries

This @value{APPENDIX} presents alphabetical lists of
all the file definitions, the code chunk definitions,
and the code chunk references.

@menu
* File Definitions::          Source files by definition.
* Code Chunk Definitions::    Code chunks by definition.
* Code Chunk References::     Code chunks by reference.
@end menu

@node File Definitions
@appendixsec Source File Definitions

@print_file_defs

@node Code Chunk Definitions
@appendixsec Code Chunk Definitions

@print_code_defs

@node Code Chunk References
@appendixsec Code Chunk References

@print_code_refs

@node Bibliography
@unnumbered Bibliography

@node Concept Index
@unnumbered Index

@printindex cp

@bye

TODO:
